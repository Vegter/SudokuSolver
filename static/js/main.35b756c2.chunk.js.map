{"version":3,"sources":["utils.ts","types/SudokuCell.ts","types/Sudoku.ts","types/SudokuConstraint.ts","types/SudokuImport.ts","types/SudokuFactory.ts","types/SudokuVariants.ts","types/SudokuStrategies/SudokuStrategy.ts","types/SudokuStrategies/HiddenPair.ts","types/SudokuStrategies/MandatoryValue.ts","types/SudokuStrategies/SingleRowColumn.ts","types/SudokuStrategies/NakedPair.ts","types/SudokuStrategies/index.ts","config.ts","components/SudokuCellEditor.tsx","components/SudokuHint.tsx","types/SudokuHelper.ts","components/SudokuOptionsEditor.tsx","components/SudokuSolver.tsx","components/SudokuEraser.tsx","components/SudokuPossibilities.tsx","components/SudokuEditor.tsx","types/SudokuStyler.ts","components/SudokuVariantSelector.tsx","components/SudokuIdSelector.tsx","components/SudokuApp.tsx","components/SudokuAppBar.tsx","App.tsx","app/SudokuSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["range","from","to","assert","Array","keys","map","v","getAllSubsets","theArray","result","reduce","subsets","value","concat","set","sort","s1","s2","length","SudokuCell","_value","this","other","isValidValue","ValidValues","includes","SudokuIndex","row","col","id","Sudoku","nRows","nCols","constraints","_nRows","_nCols","_constraints","_contents","_checksum","rowIndexes","colIndexes","indexes","index","push","setValue","allowsValue","blockedValues","Set","forEach","add","filter","isValidIndex","newValue","SudokuConstraint","area","_area","firstRow","lastRow","firstCol","lastCol","sudoku","appliesTo","getValue","constraintIndexes","constraintIndex","SudokuRowConstraint","colFrom","colTo","SudokuColumnConstraint","rowFrom","rowTo","SudokuAreaConstraint","size","SudokuImport","dataURL","setup","_data","loadJSON","window","location","href","fetch","response","json","Object","SudokuFactory","areas","areaConstraints","rowConstraints","r","colConstraints","c","getAreaConstraints","variant","create","loadData","importer","ids","getBasicConstraints","subConstraints","importDataItems","getData","fillData","fillSudoku","SudokuVariants","Basic","name","createBasicSudoku","fill","fillBasicSudoku","NRC","createNRCSudoku","fillNRCSudoku","SudokuStrategy","helper","indexInfo","HiddenPair","values","getValues","subset","allowedValues","constraint","identicalIndexes","i","n","inIndexes","action","motivation","MandatoryValue","mandatoryValue","info","applicableConstraints","nPossibilities","SingleRowColumn","rows","cols","actions","column","rowColumnConstraints","rowColumnConstraint","rowColumnIndex","NakedPair","join","identicalIds","otherIndexes","eliminateValues","strategyMapping","mapping","entries","SudokuStrategies","key","config","strategy","option","text","style","color","DefaultOptions","PossibleValues","Hint","Default","sudokuVariant","options","useStyles","makeStyles","theme","createStyles","textField","textAlign","SudokuCellEditor","props","classes","sudokuOptions","useState","noValidate","autoComplete","Input","className","disableUnderline","onChange","event","Number","target","isNaN","root","position","top","left","marginLeft","SudokuHint","sudokuHelper","onlyOneAllowed","IconButton","onClick","proposal","SudokuIndexInfo","_allowedValues","SudokuHelper","sudokuChecksum","prepare","checksum","strategies","process","SudokuOptionsEditor","React","state","setState","handleChange","checked","onOption","switches","FormControl","component","FormGroup","label","FormControlLabel","control","Switch","SudokuSolver","Button","startIcon","solve","hint","getHint","setTimeout","SudokuEraser","onErase","possibleValues","fontSize","fontFamily","possibleValue","SudokuPossibilities","anyOptionSelected","strategyValues","displayValues","lines","slice","line","classNames","SudokuEditor","change","setChange","setOptions","table","marginRight","border","borderSpacing","tableCell","backgroundColor","padding","margin","verticalAlign","width","height","getKey","Grid","container","direction","justify","alignItems","defaultBorder","boldBorder","borderTop","borderRight","borderBottom","borderLeft","getStyle","Box","mt","mb","clear","formControl","spacing","minWidth","selectEmpty","marginTop","SudokuVariantSelector","setVariant","InputLabel","Select","native","onVariant","SudokuIdSelector","setId","onId","initialState","SudokuApp","loadVariant","a","dataIds","loadId","Paper","elevation","flexGrow","menuButton","title","SudokuAppBar","AppBar","Toolbar","edge","aria-label","Typography","App","SudokuSlice","createSlice","reducers","store","configureStore","reducer","counter","sudokuReducer","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.35b756c2.chunk.js","sourcesContent":["import assert from \"assert\"\n\nexport function range(from: number, to: number | null = null): number[] {\n    if (to === null) {\n        to = from\n        from = 0\n    }\n    assert(to >= from)\n    return Array.from(Array(to - from).keys()).map(v => from + v)\n}\n\nexport function getAllSubsets<T>(theArray: T[]): T[][] {\n    const result = theArray.reduce(\n        (subsets: T[][], value: T) => subsets.concat(\n            subsets.map((set: T[]) => [...set, value])\n        ),\n        [[]] as T[][]\n    );\n    result.sort((s1: any[], s2: any[]) => s2.length - s1.length)\n    return result\n}\n\ninterface PairSearchResult {\n    [key: string]: {\n        pair: any[],\n        presences: Set<number>\n    }\n}\n\nfunction pairId<T>(pair: T[]): string {\n    return pair.join(\".\")\n}\n\nexport function getPairs<T>(theArray: T[][]) {\n    // [ [x, y], [n, m], [x, y] ] => [ [x, y], [0, 2] ]\n    const ids = theArray.map(i => pairId(i))\n    const result: PairSearchResult = {}\n    for (let i = 0; i < ids.length; i++) {\n        const id = ids[i]\n        for (let j = i + 1; j < ids.length; j++) {\n            if (ids[j] === id) {\n                result[id] = result[id] || {\n                    pair: theArray[i],\n                    presences: new Set([i])\n                }\n                result[id].presences.add(j)\n            }\n        }\n    }\n    return Object.values(result).map(v => [v.pair, Array.from(v.presences)])\n}\n\nexport function getHiddenPairs<T>(theArray: T[][]) {\n    // [ [t, v, x, z], [n, m], [u, v, w, x, y, z] ] => [ [v, x, z], [0, 2] ]\n\n    const result: PairSearchResult = {}\n    for (let i = 0; i < theArray.length; i++) {\n        for (let iSubset of getAllSubsets(theArray[i]).filter((s: T[]) => s.length > 1)) {\n            const isIncluded = [i]\n            let isHiddenPair = true\n            for (let j = 0; j < theArray.length && isHiddenPair; j++) {\n                // Does theArray[j] include all items of the subset?\n                if (j === i) continue\n                const includes = iSubset.filter(item => theArray[j].includes(item))\n                if (includes.length === iSubset.length) {\n                    isIncluded.push(j)\n                } else if (includes.length > 0) {\n                    isHiddenPair = false\n                }\n            }\n            if (isHiddenPair && isIncluded.length > 1) {\n                result[pairId(iSubset)] = result[pairId(iSubset)] || {\n                    pair: iSubset,\n                    presences: new Set()\n                }\n                isIncluded.forEach(i => result[pairId(iSubset)].presences.add(i))\n                break\n            }\n        }\n    }\n    return Object.values(result).map(v => [v.pair, Array.from(v.presences)])\n}\n","import assert from \"assert\"\nimport { range } from \"../utils\"\n\nexport type SudokuValue = number | null\n\nexport class SudokuCell {\n    static readonly ValidValues = range(1, 10)   // [1, ..., 9]\n    private _value: SudokuValue = null\n\n    constructor(value: SudokuValue = null) {\n        this.value = value\n    }\n\n    static isValidValue(value: SudokuValue) {\n        return value === null || SudokuCell.ValidValues.includes(value)\n    }\n\n    get value(): SudokuValue {\n        return this._value\n    }\n\n    set value(value: SudokuValue) {\n        assert(SudokuCell.isValidValue(value))\n        this._value = value\n    }\n\n    equals(other: SudokuCell) {\n        return this.value === other.value\n    }\n\n    get isNull() {\n        return this.value === null\n    }\n}\n","import assert from \"assert\"\nimport { SudokuCell, SudokuValue } from \"./SudokuCell\"\nimport { range } from \"../utils\"\nimport { SudokuConstraint } from \"./SudokuConstraint\"\n\nexport class SudokuIndex {\n    public readonly row: number\n    public readonly col: number\n    public readonly id: string\n\n    constructor(row: number, col: number) {\n        this.row = row\n        this.col = col\n        this.id = `${row}.${col}`\n    }\n}\n\nexport class Sudoku {\n    private _nRows: number\n    private _nCols: number\n    private _constraints: SudokuConstraint[]\n    private _contents: SudokuCell[][]\n    private _checksum: number\n\n    public readonly rowIndexes: number[]\n    public readonly colIndexes: number[]\n    public readonly indexes: SudokuIndex[]\n\n    constructor(nRows: number, nCols: number, constraints: SudokuConstraint[]) {\n        assert(nRows > 0 && nCols > 0)\n        this._nRows = nRows\n        this._nCols = nCols\n        this._constraints = constraints\n\n        this.rowIndexes = range(this._nRows)\n        this.colIndexes = range(this._nCols)\n        this.indexes = []\n\n        this._contents = []\n        for (let row of this.rowIndexes) {\n            this._contents[row] = []\n            for (let col of this.colIndexes) {\n                const index = new SudokuIndex(row, col)\n                this.indexes.push(index)\n                this.setValue(index, null)\n            }\n        }\n        this._checksum = 0\n    }\n\n    public clear(): void {\n        for (let index of this.indexes) {\n            this.setValue(index, null)\n        }\n    }\n\n    get nRows(): number {\n        return this._nRows\n    }\n\n    get nCols(): number {\n        return this._nCols\n    }\n\n    get constraints(): SudokuConstraint[] {\n        return this._constraints\n    }\n\n    public isValidIndex(index: SudokuIndex): boolean {\n        const {row, col} = index\n        return 0 <= row && row < this._nRows &&\n               0 <= col && col < this._nCols\n    }\n\n    public isValidValue(index: SudokuIndex, value: SudokuValue): boolean {\n        if (!SudokuCell.isValidValue(value)) {\n            return false\n        }\n        // value is potentially valid, next check constraints\n        for (let constraint of this._constraints) {\n            // If any constraint fails, then the value is not valid for this index\n            if (! constraint.allowsValue(this, index, value)) {\n                return false\n            }\n        }\n        // All constraints pass => value is valid for this index\n        return true\n    }\n\n    public blockedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = new Set<SudokuValue>()\n        for (let constraint of this._constraints) {\n            constraint.blockedValues(this, index).forEach(v => blockedValues.add(v))\n        }\n        return Array.from(blockedValues)\n    }\n\n    public allowedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = this.blockedValues(index)\n        return SudokuCell.ValidValues.filter(v => !blockedValues.includes(v))\n    }\n\n    public setValue(index: SudokuIndex, value: SudokuValue): void {\n        assert(this.isValidIndex(index))\n        const newValue = new SudokuCell(value)\n        assert(this.isValidValue(index, value))\n        const {row, col} = index\n        this._contents[row][col] = newValue\n        this._checksum += 1\n    }\n\n    public getValue(index: SudokuIndex): SudokuValue {\n        assert(this.isValidIndex(index))\n        const {row, col} = index\n        return this._contents[row][col].value\n    }\n\n    public get checksum() {\n        return this._checksum\n    }\n}\n","import { SudokuValue } from \"./SudokuCell\"\nimport { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { range } from \"../utils\"\n\nexport type SudokuArea = {\n    from: SudokuIndex\n    to: SudokuIndex\n}\n\nexport abstract class SudokuConstraint {\n    private readonly _area: SudokuArea\n\n    protected constructor(area: SudokuArea) {\n        this._area = area\n    }\n\n    get firstRow(): number {\n        return this._area.from.row\n    }\n\n    get lastRow(): number {\n        return this._area.to.row\n    }\n\n    get firstCol(): number {\n        return this._area.from.col\n    }\n\n    get lastCol(): number {\n        return this._area.to.col\n    }\n\n    appliesTo(index: SudokuIndex): boolean {\n        return this.firstRow <= index.row && index.row <= this.lastRow &&\n               this.firstCol <= index.col && index.col <= this.lastCol\n    }\n\n    constraintIndexes(sudoku: Sudoku): SudokuIndex[] {\n        let indexes = []\n        for (let row of range(this.firstRow, this.lastRow + 1)) {\n            for (let col of range(this.firstCol, this.lastCol + 1)) {\n                indexes.push(new SudokuIndex(row, col))\n            }\n        }\n        return indexes\n    }\n\n    blockedValues(sudoku: Sudoku, index: SudokuIndex): SudokuValue[] {\n        if (this.appliesTo(index)) {\n            const value = sudoku.getValue(index)    // don't block current value\n            return this.constraintIndexes(sudoku)\n                .map(index => sudoku.getValue(index))\n                .filter(v => !(v === null || v === value))\n        } else {\n            return []\n        }\n    }\n\n    allowsValue(sudoku: Sudoku, index: SudokuIndex, value: SudokuValue) {\n        if (value === null) {\n            // It is always possible to clear a value\n            return true\n        } else if (this.appliesTo(index)) {\n            // Check constraint\n            for (let constraintIndex of this.constraintIndexes(sudoku)) {\n                if (constraintIndex.row === index.row && constraintIndex.col === index.col) {\n                    // Overwrite of own value should be possible\n                    continue\n                }\n                if (sudoku.getValue(constraintIndex) === value) {\n                    // Value is already present in the constrained area\n                    return false\n                }\n            }\n        }\n        return true\n    }\n}\n\nexport class SudokuRowConstraint extends SudokuConstraint {\n    constructor(row: number, colFrom: number = 0, colTo: number = 8) {\n        super({from: new SudokuIndex(row, colFrom), to: new SudokuIndex(row, colTo)})\n    }\n}\n\nexport class SudokuColumnConstraint extends SudokuConstraint {\n    constructor(col: number, rowFrom: number = 0, rowTo: number = 8) {\n        super({from: new SudokuIndex(rowFrom, col), to: new SudokuIndex(rowTo, col)})\n    }\n}\n\nexport class SudokuAreaConstraint extends SudokuConstraint {\n    constructor(row: number, col: number, size: number = 3) {\n        super({from: new SudokuIndex(row, col), to: new SudokuIndex(row + size - 1, col + size - 1)})\n    }\n}\n","export type ImportDataItem = [number, number, number]\n\nexport class SudokuImport {\n    public readonly setup: Promise<void>\n    private _data: {[id: string]: ImportDataItem[]} = {}\n\n    constructor(dataURL: string) {\n        this.setup = this.loadJSON(window.location.href + dataURL)\n    }\n\n    private async loadJSON(dataURL: string) {\n        const response = await fetch(dataURL)\n        this._data = await response.json()\n    }\n\n    getData(id: string): ImportDataItem[] {\n        if (id in this._data) {\n            return this._data[id]\n        }\n        return []\n    }\n\n    get ids(): string[] {\n        return Object.keys(this._data)\n    }\n}","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { range } from \"../utils\"\nimport { SudokuAreaConstraint, SudokuColumnConstraint, SudokuConstraint, SudokuRowConstraint } from \"./SudokuConstraint\"\nimport { SudokuVariant } from \"./SudokuVariants\"\nimport { ImportDataItem, SudokuImport } from \"./SudokuImport\"\n\nexport class SudokuFactory {\n    private static _data: {[dataURL: string]: SudokuImport} = {}\n\n    private static getAreaConstraints(areas: number[]): SudokuConstraint[] {\n        const areaConstraints: SudokuConstraint[] = []\n        areas.forEach(row => {\n            areas.forEach(col => {\n                areaConstraints.push(new SudokuAreaConstraint(row, col))\n            })\n        })\n        return areaConstraints\n    }\n\n    private static getBasicConstraints(nRows: number, nCols: number): SudokuConstraint[] {\n        const rowConstraints = range(nRows).map(r => new SudokuRowConstraint(r))\n        const colConstraints = range(nCols).map(c => new SudokuColumnConstraint(c))\n        const areaConstraints = SudokuFactory.getAreaConstraints([0, 3, 6])\n        return [...rowConstraints, ...colConstraints, ...areaConstraints]\n    }\n\n    public static create(variant: SudokuVariant) {\n        return variant.create()\n    }\n\n    public static async dataIds(variant: SudokuVariant): Promise<string[]> {\n        const importer = await SudokuFactory.loadData(variant.dataURL)\n        return importer.ids\n    }\n\n    public static createBasicSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        return new Sudoku(nRows, nCols, constraints);\n    }\n\n    public static createNRCSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        const subConstraints = SudokuFactory.getAreaConstraints([1, 5])\n        return new Sudoku(nRows, nCols, [...constraints, ...subConstraints]);\n    }\n\n    private static async fillSudoku(sudoku: Sudoku, dataURL: string, id: string) {\n        const importer = await SudokuFactory.loadData(dataURL)\n        const importDataItems = importer.getData(id)\n        SudokuFactory.fillData(sudoku, importDataItems)\n    }\n\n    public static fillData(sudoku: Sudoku, importDataItems: ImportDataItem[]) {\n        // Clear any existing values\n        for (let index of sudoku.indexes) {\n            sudoku.setValue(index, null)\n        }\n\n        // Fill with new data\n        for (let [row, col, value] of importDataItems) {\n            sudoku.setValue(new SudokuIndex(row, col), value);\n        }\n    }\n\n    private static async loadData(dataURL: string): Promise<SudokuImport> {\n        if (!SudokuFactory._data[dataURL]) {\n            const importer = new SudokuImport(dataURL)\n            await importer.setup\n            SudokuFactory._data[dataURL] = importer\n        }\n        return SudokuFactory._data[dataURL]\n    }\n\n    public static async fillNRCSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/nrc.json\", id)\n    }\n\n    public static async fillBasicSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/basic.json\", id)\n    }\n}","import { SudokuFactory } from \"./SudokuFactory\"\nimport { Sudoku } from \"./Sudoku\"\n\nexport interface SudokuVariant {\n    id: string\n    name: string\n    create: () => Sudoku\n    fill: (sudoku: Sudoku, id?: string) => Promise<void>\n    dataURL: string\n}\n\nexport const SudokuVariants = {\n    Basic: {\n        id: \"Basic\",\n        name: \"Standard Sudoku\",\n        create: SudokuFactory.createBasicSudoku,\n        fill: SudokuFactory.fillBasicSudoku,\n        dataURL: \"/data/basic.json\"\n    },\n    NRC: {\n        id: \"NRC\",\n        name: \"NRC Sudoku\",\n        create: SudokuFactory.createNRCSudoku,\n        fill: SudokuFactory.fillNRCSudoku,\n        dataURL: \"/data/nrc.json\"\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuHelper } from \"../SudokuHelper\"\nimport { SudokuAction } from \"./SudokuAction\"\n\nexport abstract class SudokuStrategy {\n    protected helper: SudokuHelper\n\n    constructor(helper: SudokuHelper) {\n        this.helper = helper\n    }\n\n    public abstract values(index: SudokuIndex): SudokuValue[]\n\n    public abstract process(index: SudokuIndex): SudokuAction[]\n\n    get sudoku() {\n        return this.helper.sudoku\n    }\n\n    get indexInfo() {\n        return this.helper.indexInfo\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { getAllSubsets } from \"../../utils\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuConstraint, SudokuIndex, SudokuValue[], SudokuIndex[]]\n\nexport class HiddenPair extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const values = this.getValues(index)\n        return Array.from(\n            values.reduce((result: Set<SudokuValue>,\n                           [constraint, index, subset, identicalIndexes]: ValuesResult) => {\n                subset.forEach(v => result.add(v))\n                return result\n            }, new Set<SudokuValue>())\n        )\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const allowedValues = this.indexInfo[index.id].allowedValues\n\n        // Pairs within a constraint with identical allowed values is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Search for subsets of a minimum length of 2 and less than the length of the allowed values\n        // Length 1 cannot result in a usable set\n        const subsets = getAllSubsets(allowedValues)\n            .filter((set: SudokuValue[]) => 2 <= set.length && set.length <= allowedValues.length)\n\n        // Find any applicable constraints\n        const constraints = this.sudoku.constraints\n            .filter(c => c.appliesTo(index))\n\n        let result: ValuesResult[] = []\n        for (let subset of subsets) {\n            // Check every subset\n            for (let constraint of constraints) {\n                // Find all indexes that contain this subset\n                const identicalIndexes = constraint.constraintIndexes(this.sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (!this.indexInfo[i.id].allowedValues.includes(n)) return false\n                        }\n                        return true\n                    })\n                if (identicalIndexes.length !== subset.length) {\n                    continue\n                }\n\n                // Find all indexes that don't contain any of the subset\n                const inIndexes = constraint.constraintIndexes(this.sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (this.indexInfo[i.id].allowedValues.includes(n)) return true\n                        }\n                        return false\n                    })\n                if (identicalIndexes.length !== inIndexes.length) {\n                    continue\n                }\n\n                result.push([constraint, index, subset, identicalIndexes])\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((result: SudokuAction[],\n                              [constraint, index, subset, identicalIndexes]: ValuesResult) => {\n                result.concat(this.action(constraint, index, subset, identicalIndexes))\n                return result\n            }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   index: SudokuIndex,\n                   values: SudokuValue[],\n                   identicalIndexes: SudokuIndex[]): SudokuAction[] {\n        const result: SudokuAction[] = []\n        identicalIndexes.forEach(i => {\n            const allowedValues = this.indexInfo[i.id].allowedValues\n            if (allowedValues.length !== values.length) {\n                result.push({\n                    motivation: \"Hidden pair\",\n                    constraints: [constraint],\n                    index: i,\n                    allowedValues: values\n\n                })\n            }\n        })\n        return result\n    }\n\n\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuValue, SudokuConstraint[]]\n\nexport class MandatoryValue extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const mandatoryValue = this.getValues(index)[0]\n        return mandatoryValue ? [mandatoryValue] : []\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult {\n        const info = this.indexInfo[index.id]\n        const applicableConstraints = this.sudoku.constraints.filter(c => c.appliesTo(index))\n\n        let mandatoryValue: SudokuValue = null\n        let constraints: SudokuConstraint[] = []\n        for (let value of info.allowedValues) {\n            // Try finding a value with only one possible index within a constraint\n            for (let constraint of applicableConstraints) {\n                let nPossibilities = 0\n                for (let constraintIndex of constraint.constraintIndexes(this.sudoku)) {\n                    if (this.indexInfo[constraintIndex.id].allowedValues.includes(value)) {\n                        nPossibilities += 1\n                        if (nPossibilities > 1) {\n                            // Stop searching this constraint as it allows for multiple indexes for the given value\n                            break;\n                        }\n                    }\n                }\n                if (nPossibilities === 1) {\n                    mandatoryValue = value\n                    constraints.push(constraint)\n                }\n            }\n        }\n        return [mandatoryValue, constraints]\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const [mandatoryValue, constraints] = this.getValues(index)\n        return mandatoryValue === null ? [] : [this.action(constraints, index, mandatoryValue)]\n    }\n\n    private action(constraints: SudokuConstraint[], index: SudokuIndex, value: SudokuValue) {\n        return {\n            motivation: `Value ${value} is the only possible value in this constraint`,\n            index,\n            constraints,\n            allowedValues: [value]\n        }\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport {\n    SudokuAreaConstraint,\n    SudokuColumnConstraint,\n    SudokuConstraint,\n    SudokuRowConstraint\n} from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuValue, SudokuConstraint, number | null, number | null]\n\nexport class SingleRowColumn extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        return this.getValues(index).map(([value, constraint, row, column]: ValuesResult) => value)\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const info = this.indexInfo[index.id]\n        const applicableConstraints = this.sudoku.constraints\n            .filter(c => c.appliesTo(index))\n            .filter(constraint => constraint instanceof SudokuAreaConstraint)\n\n        let result: ValuesResult[] = []\n        for (let value of info.allowedValues) {\n            // Try finding a value with all possible values on one row or one column\n            for (let constraint of applicableConstraints) {\n                let rows = new Set<number>()\n                let cols = new Set<number>()\n                for (let constraintIndex of constraint.constraintIndexes(this.sudoku)) {\n                    if (this.indexInfo[constraintIndex.id].allowedValues.includes(value)) {\n                        rows.add(constraintIndex.row)\n                        cols.add(constraintIndex.col)\n                    }\n                }\n                if (rows.size === 1 || cols.size === 1) {\n                    result.push([value, constraint, rows.size === 1 ? index.row : null, cols.size === 1 ? index.col : null])\n                }\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((actions: SudokuAction[],\n                              [value, constraint, row, column]: ValuesResult) => {\n            return actions.concat(this.action(constraint,\n                index,\n                value,\n                row,\n                column))\n        }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   index: SudokuIndex,\n                   value: SudokuValue,\n                   row: number | null,\n                   col: number | null): SudokuAction[] {\n        let rowColumnConstraints: SudokuConstraint[] = []\n        if (row !== null) {\n            rowColumnConstraints = this.sudoku.constraints\n                .filter(c => c.appliesTo(index) && c instanceof SudokuRowConstraint && c.firstRow === row)\n        } else if (col !== null) {\n            rowColumnConstraints = this.sudoku.constraints\n                .filter(c => c.appliesTo(index) && c instanceof SudokuColumnConstraint && c.firstCol === col)\n        }\n\n        const result: SudokuAction[] = []\n        for (let rowColumnConstraint of rowColumnConstraints) {\n            for (let rowColumnIndex of rowColumnConstraint.constraintIndexes(this.sudoku).filter(i => !constraint.appliesTo(i))) {\n                const allowedValues = this.indexInfo[rowColumnIndex.id].allowedValues\n                if (allowedValues.includes(value)) {\n                    result.push({\n                        motivation: `${value} is a single row/column value`,\n                        constraints: [constraint, rowColumnConstraint],\n                        allowedValues: allowedValues.filter(v => v !== value),\n                        index: rowColumnIndex\n                    })\n                }\n            }\n        }\n        return result\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuConstraint, SudokuIndex[], SudokuValue[]]\n\nexport class NakedPair extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const values = this.getValues(index)\n        return Array.from(\n            values.reduce((result: Set<SudokuValue>,\n                           [constraint, indexes, allowedValues]: ValuesResult) => {\n                allowedValues.forEach(v => result.add(v))\n                return result\n            }, new Set<SudokuValue>())\n        )\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const info = this.indexInfo[index.id]\n        const allowedValues = info.allowedValues\n\n        // Pairs within a constraint with identical allowed value is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Find any applicable constraints\n        const applicableConstraints = this.sudoku.constraints.filter(c => c.appliesTo(index))\n\n        let result: ValuesResult[] = []\n        for (let constraint of applicableConstraints) {\n            const identicalIndexes = constraint.constraintIndexes(this.sudoku)\n                .filter(i => allowedValues.join('') === this.indexInfo[i.id].allowedValues.join(''))\n            // A pair is a set of indexes with identical values, eg [[x, y] [x, y]] or [[x, y, z] [x, y, z]]\n            if (identicalIndexes.length === allowedValues.length) {\n                // n pairs with identical n values\n                result.push([constraint, identicalIndexes, allowedValues])\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((result: SudokuAction[], [constraint, indexes, allowedValues]: ValuesResult) => {\n            return result.concat(this.action(constraint, indexes, allowedValues))\n        }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   identicalIndexes: SudokuIndex[],\n                   values: SudokuValue[]): SudokuAction[] {\n        const identicalIds = identicalIndexes.map(i => i.id)\n        const otherIndexes = constraint.constraintIndexes(this.sudoku)\n            .filter(i => !identicalIds.includes(i.id))\n        const actions: SudokuAction[] = []\n        otherIndexes.forEach(i => {\n            const info = this.indexInfo[i.id]\n            const eliminateValues = info.allowedValues.filter(v => values.includes(v))\n            if (eliminateValues.length > 0) {\n                const allowedValues = info.allowedValues.filter(v => !values.includes(v))\n                actions.push({\n                    motivation: `Eliminate naked pair values ${eliminateValues.join(\", \")}`,\n                    constraints: [constraint],\n                    index: i,\n                    allowedValues: allowedValues\n                })\n            }\n        })\n        return actions\n    }\n}\n","import { HiddenPair } from \"./HiddenPair\"\nimport { MandatoryValue } from \"./MandatoryValue\"\nimport { SingleRowColumn } from \"./SingleRowColumn\"\nimport { NakedPair } from \"./NakedPair\"\nimport { SudokuHelper } from \"../SudokuHelper\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\n\nexport interface SudokuStrategyConfig {\n    create: (helper: SudokuHelper) => SudokuStrategy,\n    option: {\n        text: string\n    },\n    style: {\n        color: string\n    }\n}\n\ninterface ISudokuStrategies {\n    MandatoryValue: SudokuStrategyConfig\n    SingleRowColumn: SudokuStrategyConfig\n    NakedPair: SudokuStrategyConfig\n    HiddenPair: SudokuStrategyConfig\n}\n\nexport type SudokuStrategyKeys = keyof ISudokuStrategies\n\nexport function strategyMapping<T>(mapping: (strategy: SudokuStrategyKeys, config: SudokuStrategyConfig) => T) {\n    return Object.entries(SudokuStrategies).reduce((result, [key, config]) => {\n        const strategy = key as SudokuStrategyKeys\n        result[strategy] = mapping(strategy as SudokuStrategyKeys, config)\n        return result\n    }, {} as Record<SudokuStrategyKeys, T>)\n}\n\nexport const SudokuStrategies: ISudokuStrategies = {\n    MandatoryValue: {\n        create: (helper: SudokuHelper) => new MandatoryValue(helper),\n        option: {\n            text: \"Show mandatory values\"\n        },\n        style: {\n            color: \"purple\"\n        }\n    },\n    NakedPair: {\n        create: (helper: SudokuHelper) => new NakedPair(helper),\n        option: {\n            text: \"Show pairs\"\n        },\n        style: {\n            color: \"red\"\n        }\n    },\n    HiddenPair: {\n        create: (helper: SudokuHelper) => new HiddenPair(helper),\n        option: {\n            text: \"Show hidden pairs\"\n        },\n        style: {\n            color: \"blue\"\n        }\n    },\n    SingleRowColumn: {\n        create: (helper: SudokuHelper) => new SingleRowColumn(helper),\n        option: {\n            text: \"Show single row/column\"\n        },\n        style: {\n            color: \"green\"\n        }\n    }\n}\n","import { SudokuVariants } from \"./types/SudokuVariants\"\nimport { strategyMapping, SudokuStrategyKeys } from \"./types/SudokuStrategies\"\n\nexport type { SudokuStrategyKeys } from \"./types/SudokuStrategies\"\nexport { SudokuStrategies, strategyMapping } from \"./types/SudokuStrategies\"\n\nexport type SudokuOptionKeys = \"PossibleValues\" |\n    \"Hint\" |\n    SudokuStrategyKeys\n\nexport type SudokuOptions = Record<SudokuOptionKeys, boolean>\n\nconst DefaultOptions: SudokuOptions = {\n    PossibleValues: false,\n    Hint: false,\n    ...strategyMapping(() => false)\n}\n\nexport const Default = {\n    sudokuVariant: SudokuVariants.Basic,\n    options: DefaultOptions\n}\n","import React, { ChangeEvent, useState } from 'react'\n\nimport { Input } from \"@material-ui/core\"\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        textField: {\n            '& > *': {\n                textAlign: \"center\",\n            },\n        }\n    }),\n);\n\nexport interface SudokuCellEditorProps {\n    sudoku: Sudoku,\n    sudokuOptions: SudokuOptions,\n    index: SudokuIndex,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nexport default function SudokuCellEditor(props: SudokuCellEditorProps) {\n    const classes = useStyles();\n\n    const { sudoku, sudokuOptions, index } = props\n\n    const [value, setValue] = useState(sudoku.getValue(index) || \"\")\n\n    const onChange = (event: ChangeEvent<HTMLInputElement>): void => {\n        const newValue: SudokuValue = Number(event.target.value)\n        const value = props.onChange(index, isNaN(newValue) ? null : newValue)\n        setValue(value || \"\")\n    }\n\n    if (sudokuOptions.Hint && !value) {\n        return null\n    }\n\n    return (\n        <form noValidate autoComplete=\"off\">\n            <Input className={classes.textField} disableUnderline={true}\n                   value={value}\n                   onChange={onChange}/>\n        </form>\n    );\n}\n","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { IconButton } from \"@material-ui/core\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            position: \"absolute\",\n            top: 7,\n            left: 8,\n            textAlign: \"center\",\n            marginLeft: \"2px\",\n        },\n    }),\n);\n\nexport interface SudokuHintProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuHint(props: SudokuHintProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    const onlyOneAllowed = sudokuHelper.onlyOneAllowed(index)\n\n    if (value !== null || !options.Hint || onlyOneAllowed === null) {\n        // Nothing for existing values\n        return null\n    }\n\n    const onProposalClick = (proposal:number) => {\n        props.onChange(index, proposal)\n    }\n\n    return (\n        <IconButton\n            className={classes.root}\n            size={\"small\"}\n            color={\"secondary\"}\n            onClick={() => onProposalClick(onlyOneAllowed)}>\n            ?\n        </IconButton>\n    )\n}\n\nexport default SudokuHint","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuValue } from \"./SudokuCell\"\nimport { strategyMapping } from \"../config\"\n\nexport class SudokuIndexInfo {\n    private _allowedValues: SudokuValue[]\n\n    constructor(allowedValues: SudokuValue[]) {\n        this._allowedValues = allowedValues\n    }\n\n    get allowedValues() {\n        return this._allowedValues\n    }\n\n    set allowedValues(values) {\n        this._allowedValues = values\n    }\n}\n\ntype Hint = [SudokuIndex, SudokuValue]\n\nexport class SudokuHelper {\n    readonly sudoku: Sudoku\n    readonly indexInfo: {\n        [key: string]: SudokuIndexInfo\n    } = {}\n    private sudokuChecksum: number\n\n    constructor(sudoku: Sudoku) {\n        this.sudoku = sudoku\n        this.sudokuChecksum = -1\n        this.prepare()\n    }\n\n    private prepare() {\n        if (this.sudokuChecksum !== this.sudoku.checksum) {\n            this.sudoku.indexes.forEach(index => {\n                const value = this.sudoku.getValue(index)\n                const allowedValues = value === null ? this.sudoku.allowedValues(index) : []\n                const indexInfo = new SudokuIndexInfo(allowedValues)\n                this.indexInfo[index.id] = indexInfo\n            })\n            this.sudokuChecksum = this.sudoku.checksum\n        }\n    }\n\n    get strategies() {\n        return strategyMapping((strategy, config) =>\n            config.create(this))\n    }\n\n    public getHint(): Hint | undefined {\n        this.prepare()\n\n        const strategies = Object.values(this.strategies)\n\n        let strategy = 0\n        do {\n            for (let index of this.sudoku.indexes) {\n                const info = this.indexInfo[index.id]\n                if (info.allowedValues.length === 1) {\n                    return [index, info.allowedValues[0]]\n                }\n            }\n\n            for (let index of this.sudoku.indexes) {\n                const actions = strategies[strategy].process(index)\n                for (let action of actions) {\n                    const info = this.indexInfo[action.index.id]\n                    info.allowedValues = action.allowedValues\n                }\n            }\n\n            strategy += 1\n        } while (strategies[strategy])\n    }\n\n    public applyHint([index, value]: Hint) {\n        this.sudoku.setValue(index, value)\n    }\n\n    public onlyOneAllowed(index: SudokuIndex): SudokuValue {\n        if (this.indexInfo[index.id]) {\n            const allowedValues = this.indexInfo[index.id].allowedValues\n            if (allowedValues.length === 1) {\n                return allowedValues[0]\n            }\n        }\n        return null\n    }\n\n    public allowedValues(index: SudokuIndex) {\n        return this.indexInfo[index.id].allowedValues\n    }\n}\n","import React from 'react';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport { SudokuOptionKeys, SudokuOptions, strategyMapping } from \"../config\"\n\nexport interface SudokuOptionsEditorProps {\n    options: SudokuOptions,\n    onOption: (name: string, value: boolean) => void\n}\n\nexport default function SudokuOptionsEditor(props: SudokuOptionsEditorProps) {\n    const [state, setState] = React.useState(props.options);\n\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { name, checked } = event.target\n        setState({ ...state, [name]: checked });\n        props.onOption(name, checked)\n    };\n\n    const switches: Record<SudokuOptionKeys, string> = {\n        PossibleValues: \"Show possible values\",\n        Hint: \"Show hint\",\n        ...strategyMapping((strategy, config) => config.option.text)\n    }\n\n    return (\n        <FormControl component=\"fieldset\">\n            <FormGroup>\n                {Object.entries(switches).map(([name, label]) => {\n                    const key = name as keyof SudokuOptions\n                    return (\n                        <FormControlLabel key={key}\n                            control={\n                                <Switch checked={state[key]}\n                                        onChange={handleChange}\n                                        name={name}/>\n                            }\n                            label={label}\n                        />\n                    )\n                })}\n            </FormGroup>\n        </FormControl>\n    );\n}\n","import React from 'react'\nimport { Button } from \"@material-ui/core\"\nimport BuildIcon from '@material-ui/icons/Build'\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuIndex } from \"../types/Sudoku\"\n\nexport interface SudokuSolverProps {\n    sudokuHelper: SudokuHelper,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuSolver(props: SudokuSolverProps) {\n    const {sudokuHelper, onChange} = props\n\n    const solve = () => {\n        const hint = sudokuHelper.getHint()\n        if (hint) {\n            const [index, value] = hint\n            onChange(index, value)\n            setTimeout(() => solve(), 0)\n        }\n    }\n\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<BuildIcon />}\n            onClick={solve}\n        >\n            Solve\n        </Button>\n    )\n}\n\nexport default SudokuSolver","import React from 'react'\n\nimport { Button } from \"@material-ui/core\"\nimport DeleteIcon from \"@material-ui/icons/Delete\"\n\nexport interface SudokuEraserProps {\n    onErase: () => void\n}\n\nfunction SudokuEraser(props: SudokuEraserProps) {\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<DeleteIcon />}\n            onClick={props.onErase}\n        >\n            Clear\n        </Button>\n    )\n}\n\nexport default SudokuEraser","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuCell, SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions, SudokuStrategyKeys, strategyMapping } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        possibleValues: {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            textAlign: \"left\",\n            marginLeft: \"2px\",\n            fontSize: \"10px\",\n            fontFamily: \"monospace\"\n        },\n        possibleValue: {},\n        ...strategyMapping((strategy, config) => config.style)\n    }),\n);\n\nexport interface SudokuPossibilitiesProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n}\n\nfunction SudokuPossibilities(props: SudokuPossibilitiesProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    // Check is any option is selected\n    const anyOptionSelected = Object.values(options)\n        .reduce((result: boolean, option: boolean) => result || option, false)\n\n    if (value !== null || !anyOptionSelected) {\n        // Nothing for existing values or when filtered out by options\n        return null\n    }\n\n    const strategies = sudokuHelper.strategies\n    const strategyValues = strategyMapping((strategy, config) =>\n        strategies[strategy].values(index))\n\n    let values: SudokuValue[] = []\n    if (options.PossibleValues) {\n        values = sudokuHelper.allowedValues(index)\n    } else {\n        values = Array.from(\n            Object.entries(strategyValues).reduce((result, [key, values]) => {\n                if (options[key as SudokuStrategyKeys]) {\n                    values.forEach(v => result.add(v))\n                }\n                return result\n            }, new Set<SudokuValue>()))\n    }\n\n    if (values.length === 0) {\n        // Nothing to show\n        return null\n    }\n\n    const displayValues = SudokuCell.ValidValues.map(v => {\n        return values.includes(v) ? v : \" \"\n    })\n    const lines = [0, 3, 6].map(n => displayValues.slice(n, n + 3))\n\n    return (\n        <div className={classes.possibleValues}>\n            {lines.map((line, i) => <div key={i}>\n                {line.map((c, i) => {\n                    if (c === \" \") {\n                        return <span key={i}>&nbsp;</span>\n                    } else {\n                        let classNames = [classes.possibleValue]\n                        Object.entries(strategyValues).forEach(([key, value]) => {\n                            const strategy = key as SudokuStrategyKeys\n                            if (options[strategy] && strategyValues[strategy].includes(c)) {\n                                classNames.push(classes[strategy])\n                            }\n                        })\n                        return <span key={i} className={classNames.join(' ')}>{c}</span>\n                    }\n                })}\n            </div>)}\n        </div>\n    )\n}\n\nexport default SudokuPossibilities","import React, { useState } from 'react'\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport SudokuCellEditor from \"./SudokuCellEditor\"\nimport SudokuHint from \"./SudokuHint\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport SudokuOptionsEditor from \"./SudokuOptionsEditor\"\nimport SudokuSolver from \"./SudokuSolver\"\nimport SudokuEraser from \"./SudokuEraser\"\nimport { Default } from \"../config\"\nimport SudokuPossibilities from \"./SudokuPossibilities\"\nimport { getStyle } from \"../types/SudokuStyler\"\nimport { Box, Grid } from \"@material-ui/core\"\n\nexport interface SudokuEditorProps {\n    sudoku: Sudoku,\n}\n\nconst CELL_WIDTH = 35\nconst CELL_HEIGHT = 35\n\nexport function SudokuEditor(props:SudokuEditorProps) {\n    const [change, setChange] = useState(\"\")\n    const [options, setOptions] = useState(Default.options)\n\n    const { sudoku } = props\n    const helper = new SudokuHelper(sudoku)\n\n    const useStyles = makeStyles({\n        table: {\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            border: \"1px solid black\",\n            borderSpacing: 0,\n        },\n        tableCell: {\n            position: \"relative\",\n            backgroundColor: \"inherit\",\n            border: \"1px solid black\",\n            padding: 0,\n            margin: 0,\n            textAlign: \"center\",\n            verticalAlign: \"center\",\n            width: CELL_WIDTH,\n            height: CELL_HEIGHT,\n        },\n    });\n    const classes = useStyles();\n\n    const getKey = (index: SudokuIndex, value: SudokuValue) => {\n        const allowedValues = helper.allowedValues(index).join('')\n        return `${index.row}.${index.col}.${value}.${allowedValues}`\n    }\n\n    const onChange = (index: SudokuIndex, value: SudokuValue) => {\n        if (sudoku.isValidValue(index, value)) {\n            sudoku.setValue(index, value)\n        } else {\n            sudoku.setValue(index, null)\n        }\n        value = sudoku.getValue(index)\n        setChange(getKey(index, value))\n        return value\n    }\n\n    const onOption = (name: string, value: boolean) => {\n        setOptions({\n            ...options,\n            [name]: value\n        })\n    }\n\n    const onErase = () => {\n        sudoku.clear()\n        setChange(\"Clear\")\n    }\n\n    // const values = sudoku.indexes\n    //     .filter(index => sudoku.getValue(index) !== null)\n    //     .map(index => [index.row, index.col, sudoku.getValue(index)])\n\n    return (\n        <div>\n        <Grid container\n              direction={\"column\"}\n              justify={\"space-around\"}\n              alignItems={\"center\"}>\n            <table className={classes.table}>\n                <tbody>\n                {sudoku.rowIndexes.map(row => {\n                    return (\n                        <tr key={row}>\n                            {sudoku.colIndexes.map(col => {\n                                const index = new SudokuIndex(row, col)\n                                const key = getKey(index, sudoku.getValue(index))\n                                const style = getStyle(sudoku, index)\n                                if (key === change) {\n                                    style.backgroundColor = \"LightBlue\"\n                                }\n                                return (\n                                    <td key={key} className={classes.tableCell} style={style}>\n                                        <SudokuPossibilities sudoku={sudoku}\n                                                             sudokuHelper={helper}\n                                                             options={options}\n                                                             index={index}/>\n                                        <SudokuHint sudoku={sudoku}\n                                                    sudokuHelper={helper}\n                                                    options={options}\n                                                    index={index}\n                                                    onChange={onChange}/>\n                                        <SudokuCellEditor sudoku={sudoku}\n                                                          sudokuOptions={options}\n                                                          index={index}\n                                                          onChange={onChange}/>\n                                    </td>\n                                )\n                            })}\n                        </tr>\n                    )\n                })}\n                </tbody>\n            </table>\n\n            </Grid>\n\n            <Grid\n                container\n                direction=\"row\"\n                justify=\"space-between\"\n                alignItems=\"flex-start\"\n            >\n\n            <SudokuOptionsEditor options={options} onOption={onOption}/>\n\n            <div style={{textAlign: \"right\"}}>\n                <Box mt={1}>\n                    <SudokuSolver sudokuHelper={helper} onChange={onChange}/>\n                </Box>\n\n                <Box mt={1} mb={2}>\n                    <SudokuEraser onErase={onErase}/>\n                </Box>\n            </div>\n\n            </Grid>\n\n            {/*<Box m={2}>*/}\n            {/*    {values.map((value, i) => (*/}\n            {/*        <div key={i}>*/}\n            {/*            [{value.join(\", \")}],*/}\n            {/*        </div>*/}\n            {/*    ))}*/}\n            {/*</Box>*/}\n\n        </div>\n    );\n}\n\nexport default SudokuEditor\n","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuAreaConstraint } from \"./SudokuConstraint\"\n\nexport function getStyle(sudoku: Sudoku, index: SudokuIndex) {\n    const defaultBorder = \"1px solid black\"\n    const boldBorder = \"2px solid black\"\n    const style = {\n        borderTop: defaultBorder,\n        borderRight: defaultBorder,\n        borderBottom: defaultBorder,\n        borderLeft: defaultBorder,\n        backgroundColor: \"inherit\"\n    }\n    for (let constraint of sudoku.constraints) {\n        if (constraint instanceof SudokuAreaConstraint) {\n            if ([1, 5].includes(constraint.firstRow) || [1,5].includes(constraint.firstCol)) {\n                if (constraint.appliesTo(index)) {\n                    style.backgroundColor = \"lightGrey\"\n                }\n                continue\n            }\n            if (index.row === constraint.firstRow) {\n                style.borderTop = boldBorder\n            } else if (index.row === constraint.lastRow) {\n                style.borderBottom = boldBorder\n            }\n            if (index.col === constraint.firstCol) {\n                style.borderLeft = boldBorder\n            } else if (index.col === constraint.lastCol) {\n                style.borderRight = boldBorder\n            }\n        }\n    }\n    return style\n}","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\nimport { SudokuVariant, SudokuVariants } from \"../types/SudokuVariants\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuVariantSelectorProps {\n    variant: SudokuVariant,\n    onVariant: (variant: SudokuVariant) => void\n}\n\nexport default function SudokuVariantSelector(props: SudokuVariantSelectorProps) {\n    const classes = useStyles();\n    const [variant, setVariant] = useState(props.variant)\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        const variant = Object.values(SudokuVariants).filter(v => v.id === id)\n        if (variant.length) {\n            setVariant(variant[0])\n            props.onVariant(variant[0])\n        }\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Variant</InputLabel>\n                <Select\n                    native\n                    value={variant.id}\n                    onChange={onChange}\n                >\n                    {Object.values(SudokuVariants).map((option: SudokuVariant) => (\n                        <option key={option.id} value={option.id}>{option.name}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuIdSelectorProps {\n    id: string,\n    ids: string[],\n    onId: (id: string) => void\n}\n\nexport default function SudokuIdSelector(props: SudokuIdSelectorProps) {\n    const classes = useStyles();\n    const [id, setId] = useState(props.id)\n    const {ids, onId} = props\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        setId(id)\n        onId(id)\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Data</InputLabel>\n                <Select\n                    native\n                    value={id}\n                    onChange={onChange}\n                >\n                    {ids.map(id => (\n                        <option key={id} value={id}>{id}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import React, { useState } from 'react'\n\nimport { Default } from \"../config\"\n\nimport { SudokuVariant } from \"../types/SudokuVariants\"\nimport { SudokuFactory } from \"../types/SudokuFactory\"\n\nimport SudokuEditor from \"./SudokuEditor\"\nimport SudokuVariantSelector from \"./SudokuVariantSelector\"\nimport { Grid, Paper } from \"@material-ui/core\"\nimport { Sudoku } from \"../types/Sudoku\"\nimport SudokuIdSelector from \"./SudokuIdSelector\"\n\nconst initialState = {\n    variant: Default.sudokuVariant,\n    ids: [] as string[],\n    id: \"\",\n    sudoku: null as Sudoku | null\n}\n\nexport default function SudokuApp() {\n    const [state, setState] = useState(initialState)\n    const {variant, ids, id, sudoku} = state\n\n    async function loadVariant(variant: SudokuVariant) {\n        const sudoku = SudokuFactory.create(variant)\n        const ids = await SudokuFactory.dataIds(variant)\n        const id = ids[0]\n        await variant.fill(sudoku, id)\n\n        setState({\n            ...state,\n            variant,\n            ids,\n            id,\n            sudoku\n        })\n    }\n\n    if (!sudoku) {\n        loadVariant(variant)\n        return (\n            <p>Loading...</p>\n        )\n    }\n\n    async function loadId(sudoku: Sudoku, id: string) {\n        await variant.fill(sudoku, id)\n    }\n\n    const onVariant = async (variant: SudokuVariant) => {\n        await loadVariant(variant)\n    }\n\n    const onId = async (id: string) => {\n        await loadId(sudoku, id)\n        setState({...state, id})\n    }\n\n    return (\n        <Paper elevation={3} style={{width: 375}}>\n            <Grid container\n                  direction={\"column\"}\n                  justify={\"space-around\"}\n                  alignItems={\"center\"}>\n                <Grid container\n                      direction={\"row\"}\n                      justify={\"space-around\"}\n                      alignItems={\"center\"}>\n                    <SudokuVariantSelector variant={variant} onVariant={onVariant}/>\n                    <SudokuIdSelector ids={ids} id={id} onId={onId}/>\n                </Grid>\n                <SudokuEditor sudoku={sudoku}/>\n            </Grid>\n        </Paper>\n    )\n}","import React from 'react';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            flexGrow: 1,\n        },\n        menuButton: {\n            marginRight: theme.spacing(2),\n        },\n        title: {\n            flexGrow: 1,\n        },\n    }),\n);\n\nexport default function SudokuAppBar() {\n    const classes = useStyles();\n\n    return (\n        <div className={classes.root}>\n            <AppBar position=\"static\">\n                <Toolbar>\n                    <IconButton edge=\"start\" className={classes.menuButton} color=\"inherit\" aria-label=\"menu\">\n                        <MenuIcon />\n                    </IconButton>\n                    <Typography variant=\"h6\" className={classes.title}>\n                        Sudoku Solver\n                    </Typography>\n                </Toolbar>\n            </AppBar>\n        </div>\n    );\n}\n","import React from 'react';\r\n\r\nimport { Box, Grid } from \"@material-ui/core\"\r\n\r\nimport SudokuApp from \"./components/SudokuApp\"\r\nimport SudokuAppBar from \"./components/SudokuAppBar\"\r\n\r\nfunction App() {\r\n    return (\r\n        <div>\r\n            <Box mb={2}>\r\n                <SudokuAppBar/>\r\n            </Box>\r\n            <Grid container\r\n                  direction={\"column\"}\r\n                  alignItems={\"center\"}\r\n                  justify={\"center\"}>\r\n                <SudokuApp/>\r\n            </Grid>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n};\n\nexport const SudokuSlice = createSlice({\n    name: 'sudoku',\n    initialState,\n    reducers: {\n    },\n});\n\nexport default SudokuSlice.reducer","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\r\nimport sudokuReducer from './SudokuSlice';\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    counter: sudokuReducer,\r\n  },\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { store } from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}