{"version":3,"sources":["utils.ts","types/SudokuCell.ts","types/Sudoku.ts","types/SudokuConstraint.ts","types/SudokuImport.ts","types/SudokuFactory.ts","types/SudokuVariants.ts","config.ts","components/SudokuCellEditor.tsx","components/SudokuHint.tsx","types/SudokuHelper.ts","components/SudokuOptionsEditor.tsx","components/SudokuSolver.tsx","components/SudokuEraser.tsx","components/SudokuPossibilities.tsx","components/SudokuEditor.tsx","types/SudokuStyler.ts","components/SudokuVariantSelector.tsx","components/SudokuIdSelector.tsx","components/SudokuApp.tsx","components/SudokuAppBar.tsx","App.tsx","app/SudokuSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["range","from","to","assert","Array","keys","map","v","SudokuCell","value","_value","this","other","isValidValue","ValidValues","includes","Sudoku","nRows","nCols","constraints","_nRows","_nCols","_constraints","_contents","rowIndexes","colIndexes","indexes","_indexes","row","col","setValue","index","allowsValue","blockedValues","Set","forEach","add","filter","isValidIndex","newValue","push","SudokuConstraint","area","_area","firstRow","lastRow","firstCol","lastCol","sudoku","appliesTo","getValue","constraintIndexes","constraintIndex","SudokuRowConstraint","colFrom","colTo","SudokuColumnConstraint","rowFrom","rowTo","SudokuAreaConstraint","size","SudokuImport","dataURL","setup","_data","loadJSON","window","location","href","fetch","response","json","id","Object","SudokuFactory","areas","areaConstraints","rowConstraints","r","colConstraints","c","getAreaConstraints","variant","create","loadData","importer","ids","getBasicConstraints","subConstraints","importDataItems","getData","fillData","fillSudoku","SudokuVariants","Basic","name","createBasicSudoku","fill","fillBasicSudoku","NRC","createNRCSudoku","fillNRCSudoku","Default","sudokuVariant","options","showPossibleValues","showHint","showPairs","showHiddenPairs","showSingleRowColumnValues","useStyles","makeStyles","theme","createStyles","textField","textAlign","SudokuCellEditor","props","classes","sudokuOptions","useState","noValidate","autoComplete","Input","className","disableUnderline","onChange","event","Number","target","isNaN","root","position","top","left","marginLeft","SudokuHint","sudokuHelper","mandatoryValue","IconButton","color","onClick","proposal","SudokuHelper","_sudoku","_info","allowedValues","pairs","hiddenPairs","singleRowColumnValues","length","getMandatoryValue","emptyIndexes","getPairs","getHiddenPairs","getSingleRowColumnValues","info","getInfo","constraint","nPossibilities","result","identicalIndexes","i","join","find","theArray","subsets","reduce","concat","set","sort","el1","el2","subset","n","inIndexes","rows","cols","SudokuOptionsEditor","React","state","setState","handleChange","checked","onOption","FormControl","component","FormGroup","entries","label","key","FormControlLabel","control","Switch","SudokuSolver","Button","startIcon","solve","hint","getHint","setTimeout","SudokuEraser","onErase","possibleValues","fontSize","fontFamily","possibleValue","singleRowColumnValue","pairValues","hiddenPairValues","SudokuPossibilities","isPair","isHiddenPair","values","displayValues","lines","slice","line","SudokuEditor","change","setChange","setOptions","helper","analyze","table","marginRight","border","borderSpacing","tableCell","backgroundColor","padding","margin","verticalAlign","width","height","getKey","Grid","container","direction","justify","alignItems","style","defaultBorder","boldBorder","borderTop","borderRight","borderBottom","borderLeft","getStyle","Box","mt","mb","clear","formControl","spacing","minWidth","selectEmpty","marginTop","SudokuVariantSelector","setVariant","InputLabel","Select","native","onVariant","option","SudokuIdSelector","setId","onId","initialState","SudokuApp","loadVariant","a","dataIds","loadId","Paper","elevation","flexGrow","menuButton","title","SudokuAppBar","AppBar","Toolbar","edge","aria-label","Typography","App","SudokuSlice","createSlice","reducers","store","configureStore","reducer","counter","sudokuReducer","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.81c509d9.chunk.js","sourcesContent":["import assert from \"assert\"\n\nexport function range(from: number, to: number | null = null): number[] {\n    if (to === null) {\n        to = from\n        from = 0\n    }\n    assert(to >= from)\n    return Array.from(Array(to - from).keys()).map(v => from + v)\n}\n\nexport const getAllSubsets =\n    (theArray: any[]) => theArray.reduce(\n        (subsets, value) => subsets.concat(\n            subsets.map((set: any) => [value,...set])\n        ),\n        [[]]\n    );\n","import assert from \"assert\"\nimport { range } from \"../utils\"\n\nexport type SudokuValue = number | null\n\nexport class SudokuCell {\n    static readonly ValidValues = range(1, 10)   // [1, ..., 9]\n    private _value: SudokuValue = null\n\n    constructor(value: SudokuValue = null) {\n        this.value = value\n    }\n\n    static isValidValue(value: SudokuValue) {\n        return value === null || SudokuCell.ValidValues.includes(value)\n    }\n\n    get value(): SudokuValue {\n        return this._value\n    }\n\n    set value(value: SudokuValue) {\n        assert(SudokuCell.isValidValue(value))\n        this._value = value\n    }\n\n    equals(other: SudokuCell) {\n        return this.value === other.value\n    }\n\n    get isNull() {\n        return this.value === null\n    }\n}\n","import assert from \"assert\"\nimport { SudokuCell, SudokuValue } from \"./SudokuCell\"\nimport { range } from \"../utils\"\nimport { SudokuConstraint } from \"./SudokuConstraint\"\n\nexport type SudokuIndex = {\n    row: number,\n    col: number\n}\n\nexport class Sudoku {\n    private _nRows: number\n    private _nCols: number\n    private _constraints: SudokuConstraint[]\n    private _contents: SudokuCell[][]\n\n    public readonly rowIndexes: number[]\n    public readonly colIndexes: number[]\n    public readonly indexes: SudokuIndex[]\n\n    constructor(nRows: number, nCols: number, constraints: SudokuConstraint[]) {\n        assert(nRows > 0 && nCols > 0)\n        this._nRows = nRows\n        this._nCols = nCols\n        this._constraints = constraints\n\n        this.rowIndexes = range(this._nRows)\n        this.colIndexes = range(this._nCols)\n        this.indexes = this._indexes\n\n        this._contents = []\n        for (let row of this.rowIndexes) {\n            this._contents[row] = []\n            for (let col of this.colIndexes) {\n                this.setValue({row, col}, null)\n            }\n        }\n    }\n\n    public clear(): void {\n        for (let index of this.indexes) {\n            this.setValue(index, null)\n        }\n    }\n\n    get nRows(): number {\n        return this._nRows\n    }\n\n    get nCols(): number {\n        return this._nCols\n    }\n\n    private get _indexes(): SudokuIndex[] {\n        const indexes = []\n        for (let row of this.rowIndexes) {\n            for (let col of this.colIndexes) {\n                indexes.push({row, col})\n            }\n        }\n        return indexes\n    }\n\n    get constraints(): SudokuConstraint[] {\n        return this._constraints\n    }\n\n    public isValidIndex(index: SudokuIndex): boolean {\n        const {row, col} = index\n        return 0 <= row && row < this._nRows &&\n               0 <= col && col < this._nCols\n    }\n\n    public isValidValue(index: SudokuIndex, value: SudokuValue): boolean {\n        if (!SudokuCell.isValidValue(value)) {\n            return false\n        }\n        // value is potentially valid, next check constraints\n        for (let constraint of this._constraints) {\n            // If any constraint fails, then the value is not valid for this index\n            if (! constraint.allowsValue(this, index, value)) {\n                return false\n            }\n        }\n        // All constraints pass => value is valid for this index\n        return true\n    }\n\n    public blockedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = new Set<SudokuValue>()\n        for (let constraint of this._constraints) {\n            constraint.blockedValues(this, index).forEach(v => blockedValues.add(v))\n        }\n        return Array.from(blockedValues)\n    }\n\n    public allowedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = this.blockedValues(index)\n        return SudokuCell.ValidValues.filter(v => !blockedValues.includes(v))\n    }\n\n    public setValue(index: SudokuIndex, value: SudokuValue): void {\n        assert(this.isValidIndex(index))\n        const newValue = new SudokuCell(value)\n        assert(this.isValidValue(index, value))\n        const {row, col} = index\n        this._contents[row][col] = newValue\n    }\n\n    public getValue(index: SudokuIndex): SudokuValue {\n        assert(this.isValidIndex(index))\n        const {row, col} = index\n        return this._contents[row][col].value\n    }\n}\n","import { SudokuValue } from \"./SudokuCell\"\nimport { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { range } from \"../utils\"\n\nexport type SudokuArea = {\n    from: SudokuIndex\n    to: SudokuIndex\n}\n\nexport abstract class SudokuConstraint {\n    private readonly _area: SudokuArea\n\n    protected constructor(area: SudokuArea) {\n        this._area = area\n    }\n\n    get firstRow(): number {\n        return this._area.from.row\n    }\n\n    get lastRow(): number {\n        return this._area.to.row\n    }\n\n    get firstCol(): number {\n        return this._area.from.col\n    }\n\n    get lastCol(): number {\n        return this._area.to.col\n    }\n\n    appliesTo(index: SudokuIndex): boolean {\n        return this.firstRow <= index.row && index.row <= this.lastRow &&\n               this.firstCol <= index.col && index.col <= this.lastCol\n    }\n\n    constraintIndexes(sudoku: Sudoku): SudokuIndex[] {\n        let indexes = []\n        for (let row of range(this.firstRow, this.lastRow + 1)) {\n            for (let col of range(this.firstCol, this.lastCol + 1)) {\n                indexes.push({row, col})\n            }\n        }\n        return indexes\n    }\n\n    blockedValues(sudoku: Sudoku, index: SudokuIndex): SudokuValue[] {\n        if (this.appliesTo(index)) {\n            const value = sudoku.getValue(index)    // don't block current value\n            return this.constraintIndexes(sudoku)\n                .map(index => sudoku.getValue(index))\n                .filter(v => !(v === null || v === value))\n        } else {\n            return []\n        }\n    }\n\n    allowsValue(sudoku: Sudoku, index: SudokuIndex, value: SudokuValue) {\n        if (value === null) {\n            // It is always possible to clear a value\n            return true\n        } else if (this.appliesTo(index)) {\n            // Check constraint\n            for (let constraintIndex of this.constraintIndexes(sudoku)) {\n                if (constraintIndex.row === index.row && constraintIndex.col === index.col) {\n                    // Overwrite of own value should be possible\n                    continue\n                }\n                if (sudoku.getValue(constraintIndex) === value) {\n                    // Value is already present in the constrained area\n                    return false\n                }\n            }\n        }\n        return true\n    }\n}\n\nexport class SudokuRowConstraint extends SudokuConstraint {\n    constructor(row: number, colFrom: number = 0, colTo: number = 8) {\n        super({from: {row, col: colFrom}, to: {row, col: colTo}})\n    }\n}\n\nexport class SudokuColumnConstraint extends SudokuConstraint {\n    constructor(col: number, rowFrom: number = 0, rowTo: number = 8) {\n        super({from: {row: rowFrom, col}, to: {row: rowTo, col}})\n    }\n}\n\nexport class SudokuAreaConstraint extends SudokuConstraint {\n    constructor(row: number, col: number, size: number = 3) {\n        super({from: {row, col}, to: {row: row + size - 1, col: col + size - 1}})\n    }\n}","export type ImportDataItem = [number, number, number]\n\nexport class SudokuImport {\n    public readonly setup: Promise<void>\n    private _data: {[id: string]: ImportDataItem[]} = {}\n\n    constructor(dataURL: string) {\n        this.setup = this.loadJSON(window.location.href + dataURL)\n    }\n\n    private async loadJSON(dataURL: string) {\n        const response = await fetch(dataURL)\n        this._data = await response.json()\n    }\n\n    getData(id: string): ImportDataItem[] {\n        if (id in this._data) {\n            return this._data[id]\n        }\n        return []\n    }\n\n    get ids(): string[] {\n        return Object.keys(this._data)\n    }\n}","import { Sudoku } from \"./Sudoku\"\nimport { range } from \"../utils\"\nimport { SudokuAreaConstraint, SudokuColumnConstraint, SudokuConstraint, SudokuRowConstraint } from \"./SudokuConstraint\"\nimport { SudokuVariant } from \"./SudokuVariants\"\nimport { ImportDataItem, SudokuImport } from \"./SudokuImport\"\n\nexport class SudokuFactory {\n    private static _data: {[dataURL: string]: SudokuImport} = {}\n\n    private static getAreaConstraints(areas: number[]): SudokuConstraint[] {\n        const areaConstraints: SudokuConstraint[] = []\n        areas.forEach(row => {\n            areas.forEach(col => {\n                areaConstraints.push(new SudokuAreaConstraint(row, col))\n            })\n        })\n        return areaConstraints\n    }\n\n    private static getBasicConstraints(nRows: number, nCols: number): SudokuConstraint[] {\n        const rowConstraints = range(nRows).map(r => new SudokuRowConstraint(r))\n        const colConstraints = range(nCols).map(c => new SudokuColumnConstraint(c))\n        const areaConstraints = SudokuFactory.getAreaConstraints([0, 3, 6])\n        return [...rowConstraints, ...colConstraints, ...areaConstraints]\n    }\n\n    public static create(variant: SudokuVariant) {\n        return variant.create()\n    }\n\n    public static async dataIds(variant: SudokuVariant): Promise<string[]> {\n        const importer = await SudokuFactory.loadData(variant.dataURL)\n        return importer.ids\n    }\n\n    public static createBasicSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        return new Sudoku(nRows, nCols, constraints);\n    }\n\n    public static createNRCSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        const subConstraints = SudokuFactory.getAreaConstraints([1, 5])\n        return new Sudoku(nRows, nCols, [...constraints, ...subConstraints]);\n    }\n\n    private static async fillSudoku(sudoku: Sudoku, dataURL: string, id: string) {\n        const importer = await SudokuFactory.loadData(dataURL)\n        const importDataItems = importer.getData(id)\n        SudokuFactory.fillData(sudoku, importDataItems)\n    }\n\n    public static fillData(sudoku: Sudoku, importDataItems: ImportDataItem[]) {\n        // Clear any existing values\n        for (let index of sudoku.indexes) {\n            sudoku.setValue(index, null)\n        }\n\n        // Fill with new data\n        for (let [row, col, value] of importDataItems) {\n            sudoku.setValue({row, col}, value);\n        }\n    }\n\n    private static async loadData(dataURL: string): Promise<SudokuImport> {\n        if (!SudokuFactory._data[dataURL]) {\n            const importer = new SudokuImport(dataURL)\n            await importer.setup\n            SudokuFactory._data[dataURL] = importer\n        }\n        return SudokuFactory._data[dataURL]\n    }\n\n    public static async fillNRCSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/nrc.json\", id)\n    }\n\n    public static async fillBasicSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/basic.json\", id)\n    }\n}","import { SudokuFactory } from \"./SudokuFactory\"\nimport { Sudoku } from \"./Sudoku\"\n\nexport interface SudokuVariant {\n    id: string\n    name: string\n    create: () => Sudoku\n    fill: (sudoku: Sudoku, id?: string) => Promise<void>\n    dataURL: string\n}\n\nexport const SudokuVariants = {\n    Basic: {\n        id: \"Basic\",\n        name: \"Standard Sudoku\",\n        create: SudokuFactory.createBasicSudoku,\n        fill: SudokuFactory.fillBasicSudoku,\n        dataURL: \"/data/basic.json\"\n    },\n    NRC: {\n        id: \"NRC\",\n        name: \"NRC Sudoku\",\n        create: SudokuFactory.createNRCSudoku,\n        fill: SudokuFactory.fillNRCSudoku,\n        dataURL: \"/data/nrc.json\"\n    }\n}\n","import { SudokuVariants } from \"./types/SudokuVariants\"\n\nexport interface SudokuOptions {\n    showPossibleValues: boolean\n    showHint: boolean\n    showPairs: boolean\n    showHiddenPairs: boolean\n    showSingleRowColumnValues: boolean\n}\n\nexport const Default = {\n    sudokuVariant: SudokuVariants.Basic,\n    options: {\n        showPossibleValues: false,\n        showHint: false,\n        showPairs: false,\n        showHiddenPairs: false,\n        showSingleRowColumnValues: false\n    }\n}\n","import React, { ChangeEvent, useState } from 'react'\n\nimport { Input } from \"@material-ui/core\"\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        textField: {\n            '& > *': {\n                textAlign: \"center\",\n            },\n        }\n    }),\n);\n\nexport interface SudokuCellEditorProps {\n    sudoku: Sudoku,\n    sudokuOptions: SudokuOptions,\n    index: SudokuIndex,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nexport default function SudokuCellEditor(props: SudokuCellEditorProps) {\n    const classes = useStyles();\n\n    const { sudoku, sudokuOptions, index } = props\n\n    const [value, setValue] = useState(sudoku.getValue(index) || \"\")\n\n    const onChange = (event: ChangeEvent<HTMLInputElement>): void => {\n        const newValue: SudokuValue = Number(event.target.value)\n        const value = props.onChange(index, isNaN(newValue) ? null : newValue)\n        setValue(value || \"\")\n    }\n\n    if (sudokuOptions.showHint && !value) {\n        return null\n    }\n\n    return (\n        <form noValidate autoComplete=\"off\">\n            <Input className={classes.textField} disableUnderline={true}\n                   value={value}\n                   onChange={onChange}/>\n        </form>\n    );\n}\n","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { IconButton } from \"@material-ui/core\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            position: \"absolute\",\n            top: 7,\n            left: 8,\n            textAlign: \"center\",\n            marginLeft: \"2px\",\n        },\n    }),\n);\n\nexport interface SudokuHintProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuHint(props: SudokuHintProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    const mandatoryValue = sudokuHelper.mandatoryValue(index)\n\n    if (value !== null || !options.showHint || mandatoryValue === null) {\n        // Nothing for existing values\n        return null\n    }\n\n    const onProposalClick = (proposal:number) => {\n        props.onChange(index, proposal)\n    }\n\n    return (\n        <IconButton\n            className={classes.root}\n            size={\"small\"}\n            color={\"secondary\"}\n            onClick={() => onProposalClick(mandatoryValue)}>\n            ?\n        </IconButton>\n    )\n}\n\nexport default SudokuHint","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuValue } from \"./SudokuCell\"\nimport { SudokuAreaConstraint } from \"./SudokuConstraint\"\nimport { getAllSubsets } from \"../utils\"\n\ntype IndexInfo = {\n    allowedValues: SudokuValue[]\n    mandatoryValue: SudokuValue\n    pairs: SudokuIndex[]\n    hiddenPairs: SudokuValue[]\n    singleRowColumnValues: SudokuValue[]\n}\n\nexport class SudokuHelper {\n    private _sudoku: Sudoku\n    private _info: IndexInfo[][]\n\n    constructor(sudoku: Sudoku) {\n        this._sudoku = sudoku\n\n        this._info = []\n        this._sudoku.rowIndexes.forEach(row => {\n            this._info[row] = []\n            this._sudoku.colIndexes.forEach(col => {\n                this._info[row][col] = {\n                    allowedValues: [],\n                    mandatoryValue: null,\n                    pairs: [],\n                    hiddenPairs: [],\n                    singleRowColumnValues: []\n                }\n            })\n        })\n    }\n\n    private getInfo(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col]\n    }\n\n    public analyze() {\n        for (let index of this._sudoku.indexes) {\n            const {row, col} = index\n            const value = this._sudoku.getValue(index)\n            if (value === null) {\n                this._info[row][col].allowedValues = this._sudoku.allowedValues(index)\n            } else {\n                this._info[row][col].allowedValues = [value]\n            }\n        }\n\n        // Find any mandatory values\n        for (let index of this._sudoku.indexes) {\n            const {row, col} = index\n            if (this.allowedValues(index).length === 1) {\n                this._info[row][col].mandatoryValue = this.allowedValues(index)[0]\n            } else {\n                this._info[row][col].mandatoryValue = this.getMandatoryValue(index)\n            }\n        }\n\n        const emptyIndexes = this._sudoku.indexes\n            .filter(index => this._sudoku.getValue(index) === null)\n\n        // Find any identical allowed values (pairs)\n        for (let index of emptyIndexes) {\n            const {row, col} = index\n            this._info[row][col].pairs = this.getPairs(index)\n            this._info[row][col].hiddenPairs = this.getHiddenPairs(index)\n        }\n\n        // Find any single column/row values\n        for (let index of emptyIndexes) {\n            const {row, col} = index\n            this._info[row][col].singleRowColumnValues = this.getSingleRowColumnValues(index)\n        }\n    }\n\n    private getMandatoryValue(index: SudokuIndex): SudokuValue {\n        const info = this.getInfo(index)\n        const constraints = this._sudoku.constraints.filter(c => c.appliesTo(index))\n\n        for (let value of info.allowedValues) {\n            // Try finding a value with only one possible index within a constraint\n            for (let constraint of constraints) {\n                let nPossibilities = 0\n                for (let constraintIndex of constraint.constraintIndexes(this._sudoku)) {\n                    if (this.getInfo(constraintIndex).allowedValues.includes(value)) {\n                        nPossibilities += 1\n                    }\n                    if (nPossibilities > 1) {\n                        // Stop searching this constraint as it allows for multiple indexes for the given value\n                        break;\n                    }\n                }\n                if (nPossibilities === 1) {\n                    // The given value is mandatory for this index\n                    return value\n                }\n            }\n        }\n        return null\n    }\n\n    private getPairs(index: SudokuIndex): SudokuIndex[] {\n        const allowedValues = this.allowedValues(index)\n\n        // Pairs within a constraint with identical allowed values is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Find any applicable constraints\n        const constraints = this._sudoku.constraints\n            .filter(c => c.appliesTo(index))\n\n        const result: SudokuIndex[] = []\n        for (let constraint of constraints) {\n            const identicalIndexes = constraint.constraintIndexes(this._sudoku)\n                .filter(i => allowedValues.join('') === this.allowedValues(i).join(''))\n            // A pair is a set of indexes with identical values, eg [[x, y] [x, y]] or [[x, y, z] [x, y, z]]\n            if (identicalIndexes.length === allowedValues.length) {\n                identicalIndexes.forEach(i => {\n                    if (! result.find(index => index.row === i.row && index.col === i.col)) {\n                        result.push(i)\n                    }\n                })\n            }\n        }\n        return result\n    }\n\n    private getHiddenPairs(index: SudokuIndex): SudokuValue[] {\n        const allowedValues = this.allowedValues(index)\n\n        // Pairs within a constraint with identical allowed values is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Search for subsets of a minimum length of 2 and less than the length of the allowed values\n        // Length 1 cannot result in a usable set, length allowed values is a naked pair (and not hidden)\n        const subsets = getAllSubsets(allowedValues)\n            .filter((set: number[]) => 2 <= set.length && set.length < allowedValues.length)\n        subsets.sort((el1: number[], el2: number[]) => el2.length - el1.length)\n\n        // Find any applicable constraints\n        const constraints = this._sudoku.constraints\n            .filter(c => c.appliesTo(index))\n\n        const result = new Set<SudokuValue>()\n        for (let subset of subsets) {\n            // Check every subset\n            for (let constraint of constraints) {\n                // Find all indexes that contain this subset\n                const identicalIndexes = constraint.constraintIndexes(this._sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (!this.allowedValues(i).includes(n)) return false\n                        }\n                        return true\n                    })\n                if (identicalIndexes.length !== subset.length) {\n                    continue\n                }\n\n                // Find all indexes that don't contain any of the subset\n                const inIndexes = constraint.constraintIndexes(this._sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (this.allowedValues(i).includes(n)) return true\n                        }\n                        return false\n                    })\n                if (identicalIndexes.length !== inIndexes.length) {\n                    continue\n                }\n\n                subset.forEach((v: number) => result.add(v))\n            }\n        }\n        return Array.from(result)\n    }\n\n    private getSingleRowColumnValues(index: SudokuIndex): SudokuValue[] {\n        const info = this.getInfo(index)\n        const constraints = this._sudoku.constraints\n            .filter(c => c.appliesTo(index))\n            .filter(constraint => constraint instanceof SudokuAreaConstraint)\n\n        const result: SudokuValue[] = []\n        for (let value of info.allowedValues) {\n            // Try finding a value with all possible values on one row or one column\n            for (let constraint of constraints) {\n                let rows = new Set()\n                let cols = new Set()\n                for (let constraintIndex of constraint.constraintIndexes(this._sudoku)) {\n                    if (this.getInfo(constraintIndex).allowedValues.includes(value)) {\n                        rows.add(constraintIndex.row)\n                        cols.add(constraintIndex.col)\n                    }\n                }\n                if (rows.size === 1 || cols.size === 1) {\n                    result.push(value)\n                }\n            }\n        }\n        return result\n    }\n\n    public getHint(): [SudokuIndex, SudokuValue] | undefined {\n        for (let index of this._sudoku.indexes) {\n            const mandatoryValue = this.mandatoryValue(index)\n            if (this._sudoku.getValue(index) === null && mandatoryValue !== null) {\n                return [index, mandatoryValue]\n            }\n        }\n    }\n\n    public fillAllowedValues() {\n        for (let index of this._sudoku.indexes) {\n            const value = this._sudoku.getValue(index)\n            if (value === null) {\n                this.getInfo(index).allowedValues = this._sudoku.allowedValues(index)\n            } else {\n                this.getInfo(index).allowedValues = [value]\n            }\n        }\n    }\n\n    public fillMandatoryValues() {\n        for (let index of this._sudoku.indexes) {\n            const value = this._sudoku.getValue(index)\n            if (value !== null) {\n                // Value is already known, do not calculate any mandatory value\n                this.getInfo(index).mandatoryValue = null\n            } else if (this.allowedValues(index).length === 1) {\n                // Only one value is possible for the index\n                this.getInfo(index).mandatoryValue = this.allowedValues(index)[0]\n            } else {\n                // Check is any of the values is unique within a constraint\n                this.getInfo(index).mandatoryValue = this.getMandatoryValue(index)\n            }\n        }\n    }\n\n    public fillPairs() {\n        for (let index of this._sudoku.indexes) {\n            const info = this.getInfo(index)\n            // Find any indexes with identical allowed values\n            info.pairs = this.getPairs(index)\n        }\n    }\n\n    public fillHiddenPairs() {\n        for (let index of this._sudoku.indexes) {\n            const info = this.getInfo(index)\n            // Find any indexes with hidden identical allowed values\n            info.hiddenPairs = this.getHiddenPairs(index)\n        }\n    }\n\n    public allowedValues(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col].allowedValues\n    }\n\n    public mandatoryValue(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col].mandatoryValue\n    }\n\n    public pairs(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col].pairs\n    }\n\n    public hiddenPairs(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col].hiddenPairs\n    }\n\n    public singleRowColumnValues(index: SudokuIndex) {\n        const {row, col} = index\n        return this._info[row][col].singleRowColumnValues\n    }\n}\n","import React from 'react';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport { SudokuOptions } from \"../config\"\n\nexport interface SudokuOptionsEditorProps {\n    options: SudokuOptions,\n    onOption: (name: string, value: boolean) => void\n}\n\nexport default function SudokuOptionsEditor(props: SudokuOptionsEditorProps) {\n    const [state, setState] = React.useState(props.options);\n\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { name, checked } = event.target\n        setState({ ...state, [name]: checked });\n        props.onOption(name, checked)\n    };\n\n    const switches = {\n        showPossibleValues: \"Show possible values\",\n        showHint: \"Show hint\",\n        showPairs: \"Show pairs\",\n        showHiddenPairs: \"Show hidden pairs\",\n        showSingleRowColumnValues: \"Show single row/columns\",\n    }\n\n    return (\n        <FormControl component=\"fieldset\">\n            <FormGroup>\n                {Object.entries(switches).map(([name, label]) => {\n                    const key = name as keyof SudokuOptions\n                    return (\n                        <FormControlLabel key={key}\n                            control={\n                                <Switch checked={state[key]}\n                                        onChange={handleChange}\n                                        name={name}/>\n                            }\n                            label={label}\n                        />\n                    )\n                })}\n            </FormGroup>\n        </FormControl>\n    );\n}\n","import React from 'react'\nimport { Button } from \"@material-ui/core\"\nimport BuildIcon from '@material-ui/icons/Build'\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuIndex } from \"../types/Sudoku\"\n\nexport interface SudokuSolverProps {\n    sudokuHelper: SudokuHelper,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuSolver(props: SudokuSolverProps) {\n    const {sudokuHelper, onChange} = props\n\n    const solve = () => {\n        const hint = sudokuHelper.getHint()\n        if (hint) {\n            const [index, value] = hint\n            onChange(index, value)\n            setTimeout(() => solve(), 0)\n        }\n    }\n\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<BuildIcon />}\n            onClick={solve}\n        >\n            Solve\n        </Button>\n    )\n}\n\nexport default SudokuSolver","import React from 'react'\n\nimport { Button } from \"@material-ui/core\"\nimport DeleteIcon from \"@material-ui/icons/Delete\"\n\nexport interface SudokuEraserProps {\n    onErase: () => void\n}\n\nfunction SudokuEraser(props: SudokuEraserProps) {\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<DeleteIcon />}\n            onClick={props.onErase}\n        >\n            Clear\n        </Button>\n    )\n}\n\nexport default SudokuEraser","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuCell, SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        possibleValues: {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            textAlign: \"left\",\n            marginLeft: \"2px\",\n            fontSize: \"10px\",\n            fontFamily: \"monospace\"\n        },\n        possibleValue: {\n        },\n        singleRowColumnValue: {\n            color: \"green\"\n        },\n        pairValues: {\n            color: \"red\",\n        },\n        hiddenPairValues: {\n            color: \"blue\"\n        }\n    }),\n);\n\nexport interface SudokuPossibilitiesProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n}\n\nfunction SudokuPossibilities(props: SudokuPossibilitiesProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    const {showPossibleValues, showPairs, showSingleRowColumnValues, showHiddenPairs} = options\n\n    if (value !== null || !(showPossibleValues || showPairs || showSingleRowColumnValues || showHiddenPairs)) {\n        // Nothing for existing values or when filtered out by options\n        return null\n    }\n\n    const possibleValues = sudokuHelper.allowedValues(index)\n    const singleRowColumnValues = sudokuHelper.singleRowColumnValues(index)\n    const isPair = sudokuHelper.pairs(index).length > 0\n    const hiddenPairs = sudokuHelper.hiddenPairs(index)\n    const isHiddenPair = hiddenPairs.length > 0\n\n    let values: SudokuValue[] = []\n    if (showPossibleValues) {\n        values = possibleValues\n    } else {\n        if (showPairs && isPair) {\n            values = possibleValues\n        } else if (showHiddenPairs && isHiddenPair) {\n            values = hiddenPairs\n            // hiddenPairs.forEach(pair => {\n            //     pair.forEach((v: number) => values.push(v))\n            // }\n        } else if (showSingleRowColumnValues) {\n            values = singleRowColumnValues\n        }\n    }\n\n    if (values.length === 0) {\n        // Nothing to show\n        return null\n    }\n\n    const displayValues = SudokuCell.ValidValues.map(v => {\n        return values.includes(v) ? v : \" \"\n    })\n    const lines = [0, 3, 6].map(n => displayValues.slice(n, n + 3))\n\n    return (\n        <div className={classes.possibleValues}>\n            {lines.map((line, i) => <div key={i}>\n                {line.map((c, i) => {\n                    if (c === \" \") {\n                        return <span key={i}>&nbsp;</span>\n                    } else {\n                        let className = classes.possibleValue\n                        if (showPairs && isPair) {\n                            className = classes.pairValues\n                        }\n                        if (showHiddenPairs && isHiddenPair) {\n                            className = classes.hiddenPairValues\n                        }\n                        if (showSingleRowColumnValues && singleRowColumnValues.includes(c)) {\n                            className = classes.singleRowColumnValue\n                        }\n                        return <span key={i} className={className}>{c}</span>\n                    }\n                })}\n            </div>)}\n        </div>\n    )\n}\n\nexport default SudokuPossibilities","import React, { useState } from 'react'\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport SudokuCellEditor from \"./SudokuCellEditor\"\nimport SudokuHint from \"./SudokuHint\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport SudokuOptionsEditor from \"./SudokuOptionsEditor\"\nimport SudokuSolver from \"./SudokuSolver\"\nimport SudokuEraser from \"./SudokuEraser\"\nimport { Default } from \"../config\"\nimport SudokuPossibilities from \"./SudokuPossibilities\"\nimport { getStyle } from \"../types/SudokuStyler\"\nimport { Box, Grid } from \"@material-ui/core\"\n\nexport interface SudokuEditorProps {\n    sudoku: Sudoku,\n}\n\nconst CELL_WIDTH = 35\nconst CELL_HEIGHT = 35\n\nexport function SudokuEditor(props:SudokuEditorProps) {\n    const [change, setChange] = useState(\"\")\n    const [options, setOptions] = useState(Default.options)\n\n    const { sudoku } = props\n\n    const helper = new SudokuHelper(sudoku)\n    helper.analyze()\n\n    const useStyles = makeStyles({\n        table: {\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            border: \"1px solid black\",\n            borderSpacing: 0,\n        },\n        tableCell: {\n            position: \"relative\",\n            backgroundColor: \"inherit\",\n            border: \"1px solid black\",\n            padding: 0,\n            margin: 0,\n            textAlign: \"center\",\n            verticalAlign: \"center\",\n            width: CELL_WIDTH,\n            height: CELL_HEIGHT,\n        },\n    });\n    const classes = useStyles();\n\n    const getKey = (index: SudokuIndex, value: SudokuValue) => {\n        return `${index.row}.${index.col}.${value}`\n    }\n\n    const onChange = (index: SudokuIndex, value: SudokuValue) => {\n        if (sudoku.isValidValue(index, value)) {\n            sudoku.setValue(index, value)\n        } else {\n            sudoku.setValue(index, null)\n        }\n        value = sudoku.getValue(index)\n        setChange(getKey(index, value))\n        helper.analyze()\n        return value\n    }\n\n    const onOption = (name: string, value: boolean) => {\n        setOptions({\n            ...options,\n            [name]: value\n        })\n    }\n\n    const onErase = () => {\n        sudoku.clear()\n        setChange(\"Clear\")\n    }\n\n    // const values = sudoku.indexes\n    //     .filter(index => sudoku.getValue(index) !== null)\n    //     .map(index => [index.row, index.col, sudoku.getValue(index)])\n\n    return (\n        <div>\n        <Grid container\n              direction={\"column\"}\n              justify={\"space-around\"}\n              alignItems={\"center\"}>\n            <table className={classes.table}>\n                <tbody>\n                {sudoku.rowIndexes.map(row => {\n                    return (\n                        <tr key={row}>\n                            {sudoku.colIndexes.map(col => {\n                                const index = {row, col}\n                                const key = getKey(index, sudoku.getValue(index))\n                                const style = getStyle(sudoku, index)\n                                if (key === change) {\n                                    style.backgroundColor = \"LightBlue\"\n                                }\n                                return (\n                                    <td key={key} className={classes.tableCell} style={style}>\n                                        <SudokuPossibilities sudoku={sudoku}\n                                                             sudokuHelper={helper}\n                                                             options={options}\n                                                             index={index}/>\n                                        <SudokuHint sudoku={sudoku}\n                                                    sudokuHelper={helper}\n                                                    options={options}\n                                                    index={index}\n                                                    onChange={onChange}/>\n                                        <SudokuCellEditor sudoku={sudoku}\n                                                          sudokuOptions={options}\n                                                          index={index}\n                                                          onChange={onChange}/>\n                                    </td>\n                                )\n                            })}\n                        </tr>\n                    )\n                })}\n                </tbody>\n            </table>\n\n            </Grid>\n\n            <Grid\n                container\n                direction=\"row\"\n                justify=\"space-between\"\n                alignItems=\"flex-start\"\n            >\n\n            <SudokuOptionsEditor options={options} onOption={onOption}/>\n\n            <div style={{textAlign: \"right\"}}>\n                <Box mt={1}>\n                    <SudokuSolver sudokuHelper={helper} onChange={onChange}/>\n                </Box>\n\n                <Box mt={1} mb={2}>\n                    <SudokuEraser onErase={onErase}/>\n                </Box>\n            </div>\n\n            </Grid>\n\n            {/*<Box m={2}>*/}\n            {/*    {values.map((value, i) => (*/}\n            {/*        <div key={i}>*/}\n            {/*            [{value.join(\", \")}],*/}\n            {/*        </div>*/}\n            {/*    ))}*/}\n            {/*</Box>*/}\n\n        </div>\n    );\n}\n\nexport default SudokuEditor\n","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuAreaConstraint } from \"./SudokuConstraint\"\n\nexport function getStyle(sudoku: Sudoku, index: SudokuIndex) {\n    const defaultBorder = \"1px solid black\"\n    const boldBorder = \"2px solid black\"\n    const style = {\n        borderTop: defaultBorder,\n        borderRight: defaultBorder,\n        borderBottom: defaultBorder,\n        borderLeft: defaultBorder,\n        backgroundColor: \"inherit\"\n    }\n    for (let constraint of sudoku.constraints) {\n        if (constraint instanceof SudokuAreaConstraint) {\n            if ([1, 5].includes(constraint.firstRow) || [1,5].includes(constraint.firstCol)) {\n                if (constraint.appliesTo(index)) {\n                    style.backgroundColor = \"lightGrey\"\n                }\n                continue\n            }\n            if (index.row === constraint.firstRow) {\n                style.borderTop = boldBorder\n            } else if (index.row === constraint.lastRow) {\n                style.borderBottom = boldBorder\n            }\n            if (index.col === constraint.firstCol) {\n                style.borderLeft = boldBorder\n            } else if (index.col === constraint.lastCol) {\n                style.borderRight = boldBorder\n            }\n        }\n    }\n    return style\n}","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\nimport { SudokuVariant, SudokuVariants } from \"../types/SudokuVariants\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuVariantSelectorProps {\n    variant: SudokuVariant,\n    onVariant: (variant: SudokuVariant) => void\n}\n\nexport default function SudokuVariantSelector(props: SudokuVariantSelectorProps) {\n    const classes = useStyles();\n    const [variant, setVariant] = useState(props.variant)\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        const variant = Object.values(SudokuVariants).filter(v => v.id === id)\n        if (variant.length) {\n            setVariant(variant[0])\n            props.onVariant(variant[0])\n        }\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Variant</InputLabel>\n                <Select\n                    native\n                    value={variant.id}\n                    onChange={onChange}\n                >\n                    {Object.values(SudokuVariants).map((option: SudokuVariant) => (\n                        <option key={option.id} value={option.id}>{option.name}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuIdSelectorProps {\n    id: string,\n    ids: string[],\n    onId: (id: string) => void\n}\n\nexport default function SudokuIdSelector(props: SudokuIdSelectorProps) {\n    const classes = useStyles();\n    const [id, setId] = useState(props.id)\n    const {ids, onId} = props\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        setId(id)\n        onId(id)\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Data</InputLabel>\n                <Select\n                    native\n                    value={id}\n                    onChange={onChange}\n                >\n                    {ids.map(id => (\n                        <option key={id} value={id}>{id}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import React, { useState } from 'react'\n\nimport { Default } from \"../config\"\n\nimport { SudokuVariant } from \"../types/SudokuVariants\"\nimport { SudokuFactory } from \"../types/SudokuFactory\"\n\nimport SudokuEditor from \"./SudokuEditor\"\nimport SudokuVariantSelector from \"./SudokuVariantSelector\"\nimport { Grid, Paper } from \"@material-ui/core\"\nimport { Sudoku } from \"../types/Sudoku\"\nimport SudokuIdSelector from \"./SudokuIdSelector\"\n\nconst initialState = {\n    variant: Default.sudokuVariant,\n    ids: [] as string[],\n    id: \"\",\n    sudoku: null as Sudoku | null\n}\n\nexport default function SudokuApp() {\n    const [state, setState] = useState(initialState)\n    const {variant, ids, id, sudoku} = state\n\n    async function loadVariant(variant: SudokuVariant) {\n        const sudoku = SudokuFactory.create(variant)\n        const ids = await SudokuFactory.dataIds(variant)\n        const id = ids[0]\n        await variant.fill(sudoku, id)\n\n        setState({\n            ...state,\n            variant,\n            ids,\n            id,\n            sudoku\n        })\n    }\n\n    if (!sudoku) {\n        loadVariant(variant)\n        return (\n            <p>Loading...</p>\n        )\n    }\n\n    async function loadId(sudoku: Sudoku, id: string) {\n        await variant.fill(sudoku, id)\n    }\n\n    const onVariant = async (variant: SudokuVariant) => {\n        await loadVariant(variant)\n    }\n\n    const onId = async (id: string) => {\n        await loadId(sudoku, id)\n        setState({...state, id})\n    }\n\n    return (\n        <Paper elevation={3} style={{width: 375}}>\n            <Grid container\n                  direction={\"column\"}\n                  justify={\"space-around\"}\n                  alignItems={\"center\"}>\n                <Grid container\n                      direction={\"row\"}\n                      justify={\"space-around\"}\n                      alignItems={\"center\"}>\n                    <SudokuVariantSelector variant={variant} onVariant={onVariant}/>\n                    <SudokuIdSelector ids={ids} id={id} onId={onId}/>\n                </Grid>\n                <SudokuEditor sudoku={sudoku}/>\n            </Grid>\n        </Paper>\n    )\n}","import React from 'react';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            flexGrow: 1,\n        },\n        menuButton: {\n            marginRight: theme.spacing(2),\n        },\n        title: {\n            flexGrow: 1,\n        },\n    }),\n);\n\nexport default function SudokuAppBar() {\n    const classes = useStyles();\n\n    return (\n        <div className={classes.root}>\n            <AppBar position=\"static\">\n                <Toolbar>\n                    <IconButton edge=\"start\" className={classes.menuButton} color=\"inherit\" aria-label=\"menu\">\n                        <MenuIcon />\n                    </IconButton>\n                    <Typography variant=\"h6\" className={classes.title}>\n                        Sudoku Solver\n                    </Typography>\n                </Toolbar>\n            </AppBar>\n        </div>\n    );\n}\n","import React from 'react';\r\n\r\nimport { Box, Grid } from \"@material-ui/core\"\r\n\r\nimport SudokuApp from \"./components/SudokuApp\"\r\nimport SudokuAppBar from \"./components/SudokuAppBar\"\r\n\r\nfunction App() {\r\n    return (\r\n        <div>\r\n            <Box mb={2}>\r\n                <SudokuAppBar/>\r\n            </Box>\r\n            <Grid container\r\n                  direction={\"column\"}\r\n                  alignItems={\"center\"}\r\n                  justify={\"center\"}>\r\n                <SudokuApp/>\r\n            </Grid>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n};\n\nexport const SudokuSlice = createSlice({\n    name: 'sudoku',\n    initialState,\n    reducers: {\n    },\n});\n\nexport default SudokuSlice.reducer","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\r\nimport sudokuReducer from './SudokuSlice';\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    counter: sudokuReducer,\r\n  },\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { store } from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}