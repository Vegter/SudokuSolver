{"version":3,"sources":["utils.ts","types/SudokuCell.ts","types/Sudoku.ts","types/SudokuConstraint.ts","types/SudokuImport.ts","types/SudokuFactory.ts","types/SudokuVariants.ts","types/SudokuStrategies/SudokuStrategy.ts","types/SudokuStrategies/HiddenPair.ts","types/SudokuStrategies/MandatoryValue.ts","types/SudokuStrategies/SingleRowColumn.ts","types/SudokuStrategies/NakedPair.ts","types/SudokuStrategies/index.ts","config.ts","components/SudokuCellEditor.tsx","components/SudokuHint.tsx","components/SudokuOptionsEditor.tsx","components/SudokuSolver.tsx","components/SudokuEraser.tsx","components/SudokuPossibilities.tsx","components/SudokuActionProposal.tsx","components/SudokuEditor.tsx","types/SudokuStyler.ts","components/SudokuVariantSelector.tsx","components/SudokuIdSelector.tsx","types/SudokuHelper.ts","components/SudokuApp.tsx","components/SudokuAppBar.tsx","App.tsx","app/SudokuSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["range","from","to","assert","Array","keys","map","v","getAllSubsets","theArray","result","reduce","subsets","value","concat","set","sort","s1","s2","length","SudokuCell","_value","this","other","isValidValue","ValidValues","includes","SudokuIndex","row","col","id","Sudoku","nRows","nCols","constraints","_nRows","_nCols","_constraints","_contents","rowIndexes","colIndexes","indexes","index","push","setValue","allowsValue","blockedValues","Set","forEach","add","filter","isValidIndex","newValue","_checksum","SudokuConstraint","area","_area","firstRow","lastRow","firstCol","lastCol","sudoku","appliesTo","getValue","constraintIndexes","constraintIndex","SudokuRowConstraint","colFrom","colTo","SudokuColumnConstraint","rowFrom","rowTo","SudokuAreaConstraint","size","SudokuImport","dataURL","setup","_data","loadJSON","window","location","href","fetch","response","json","Object","SudokuFactory","areas","areaConstraints","rowConstraints","r","colConstraints","c","getAreaConstraints","variant","create","loadData","importer","ids","getBasicConstraints","subConstraints","importDataItems","getData","fillData","fillSudoku","SudokuVariants","Basic","name","createBasicSudoku","fill","fillBasicSudoku","NRC","createNRCSudoku","fillNRCSudoku","SudokuStrategy","helper","indexInfo","HiddenPair","values","getValues","subset","allowedValues","constraint","identicalIndexes","i","n","inIndexes","action","motivation","MandatoryValue","mandatoryValue","info","applicableConstraints","nPossibilities","SingleRowColumn","rows","cols","actions","column","rowColumnConstraints","rowColumnConstraint","rowColumnIndex","NakedPair","join","identicalIds","otherIndexes","eliminateValues","strategyMapping","mapping","entries","SudokuStrategies","key","config","strategy","option","text","style","color","DefaultOptions","PossibleValues","Hint","Default","sudokuVariant","options","useStyles","makeStyles","theme","createStyles","textField","textAlign","SudokuCellEditor","props","classes","sudokuOptions","useState","noValidate","autoComplete","Input","className","disableUnderline","onChange","event","Number","target","isNaN","root","position","top","left","marginLeft","SudokuHint","sudokuHelper","IconButton","onClick","proposal","SudokuOptionsEditor","React","state","setState","handleChange","checked","onOption","switches","FormControl","component","FormGroup","label","FormControlLabel","control","Switch","SudokuSolver","Button","startIcon","solve","hint","getHint","setTimeout","SudokuEraser","onErase","possibleValues","fontSize","fontFamily","possibleValue","SudokuPossibilities","anyOptionSelected","strategies","strategyValues","displayValues","lines","slice","line","classNames","SudokuActionProposal","actionProposals","title","onAction","SudokuEditor","change","setChange","setOptions","table","marginRight","border","borderSpacing","tableCell","backgroundColor","padding","margin","verticalAlign","width","height","getKey","applyActions","Grid","container","direction","justify","alignItems","defaultBorder","boldBorder","borderTop","borderRight","borderBottom","borderLeft","getStyle","Box","mt","mb","clear","formControl","spacing","minWidth","selectEmpty","marginTop","SudokuVariantSelector","setVariant","InputLabel","Select","native","onVariant","SudokuIdSelector","setId","onId","SudokuIndexInfo","_allowedValues","SudokuHelper","sudokuChecksum","_actions","prepare","checksum","getActions","process","actionsApplied","refreshActions","initialState","SudokuApp","loadVariant","a","dataIds","loadId","Paper","elevation","flexGrow","menuButton","SudokuAppBar","AppBar","Toolbar","edge","aria-label","Typography","App","SudokuSlice","createSlice","reducers","store","configureStore","reducer","counter","sudokuReducer","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4317d3f0.chunk.js","sourcesContent":["import assert from \"assert\"\n\nexport function range(from: number, to: number | null = null): number[] {\n    if (to === null) {\n        to = from\n        from = 0\n    }\n    assert(to >= from)\n    return Array.from(Array(to - from).keys()).map(v => from + v)\n}\n\nexport function getAllSubsets<T>(theArray: T[]): T[][] {\n    const result = theArray.reduce(\n        (subsets: T[][], value: T) => subsets.concat(\n            subsets.map((set: T[]) => [...set, value])\n        ),\n        [[]] as T[][]\n    );\n    result.sort((s1: any[], s2: any[]) => s2.length - s1.length)\n    return result\n}\n\ninterface PairSearchResult {\n    [key: string]: {\n        pair: any[],\n        presences: Set<number>\n    }\n}\n\nfunction pairId<T>(pair: T[]): string {\n    return pair.join(\".\")\n}\n\nexport function getPairs<T>(theArray: T[][]) {\n    // [ [x, y], [n, m], [x, y] ] => [ [x, y], [0, 2] ]\n    const ids = theArray.map(i => pairId(i))\n    const result: PairSearchResult = {}\n    for (let i = 0; i < ids.length; i++) {\n        const id = ids[i]\n        for (let j = i + 1; j < ids.length; j++) {\n            if (ids[j] === id) {\n                result[id] = result[id] || {\n                    pair: theArray[i],\n                    presences: new Set([i])\n                }\n                result[id].presences.add(j)\n            }\n        }\n    }\n    return Object.values(result).map(v => [v.pair, Array.from(v.presences)])\n}\n\nexport function getHiddenPairs<T>(theArray: T[][]) {\n    // [ [t, v, x, z], [n, m], [u, v, w, x, y, z] ] => [ [v, x, z], [0, 2] ]\n\n    const result: PairSearchResult = {}\n    for (let i = 0; i < theArray.length; i++) {\n        for (let iSubset of getAllSubsets(theArray[i]).filter((s: T[]) => s.length > 1)) {\n            const isIncluded = [i]\n            let isHiddenPair = true\n            for (let j = 0; j < theArray.length && isHiddenPair; j++) {\n                // Does theArray[j] include all items of the subset?\n                if (j === i) continue\n                const includes = iSubset.filter(item => theArray[j].includes(item))\n                if (includes.length === iSubset.length) {\n                    isIncluded.push(j)\n                } else if (includes.length > 0) {\n                    isHiddenPair = false\n                }\n            }\n            if (isHiddenPair && isIncluded.length > 1) {\n                result[pairId(iSubset)] = result[pairId(iSubset)] || {\n                    pair: iSubset,\n                    presences: new Set()\n                }\n                isIncluded.forEach(i => result[pairId(iSubset)].presences.add(i))\n                break\n            }\n        }\n    }\n    return Object.values(result).map(v => [v.pair, Array.from(v.presences)])\n}\n","import assert from \"assert\"\nimport { range } from \"../utils\"\n\nexport type SudokuValue = number | null\n\nexport class SudokuCell {\n    static readonly ValidValues = range(1, 10)   // [1, ..., 9]\n    private _value: SudokuValue = null\n\n    constructor(value: SudokuValue = null) {\n        this.value = value\n    }\n\n    static isValidValue(value: SudokuValue) {\n        return value === null || SudokuCell.ValidValues.includes(value)\n    }\n\n    get value(): SudokuValue {\n        return this._value\n    }\n\n    set value(value: SudokuValue) {\n        assert(SudokuCell.isValidValue(value))\n        this._value = value\n    }\n\n    equals(other: SudokuCell) {\n        return this.value === other.value\n    }\n\n    get isNull() {\n        return this.value === null\n    }\n}\n","import assert from \"assert\"\nimport { SudokuCell, SudokuValue } from \"./SudokuCell\"\nimport { range } from \"../utils\"\nimport { SudokuConstraint } from \"./SudokuConstraint\"\n\nexport class SudokuIndex {\n    public readonly row: number\n    public readonly col: number\n    public readonly id: string\n\n    constructor(row: number, col: number) {\n        this.row = row\n        this.col = col\n        this.id = `${row}.${col}`\n    }\n}\n\nexport class Sudoku {\n    private static _checksum:number = 0\n\n    private _nRows: number\n    private _nCols: number\n    private _constraints: SudokuConstraint[]\n    private _contents: SudokuCell[][]\n\n    public readonly rowIndexes: number[]\n    public readonly colIndexes: number[]\n    public readonly indexes: SudokuIndex[]\n\n    constructor(nRows: number, nCols: number, constraints: SudokuConstraint[]) {\n        assert(nRows > 0 && nCols > 0)\n        this._nRows = nRows\n        this._nCols = nCols\n        this._constraints = constraints\n\n        this.rowIndexes = range(this._nRows)\n        this.colIndexes = range(this._nCols)\n        this.indexes = []\n\n        this._contents = []\n        for (let row of this.rowIndexes) {\n            this._contents[row] = []\n            for (let col of this.colIndexes) {\n                const index = new SudokuIndex(row, col)\n                this.indexes.push(index)\n                this.setValue(index, null)\n            }\n        }\n    }\n\n    public clear(): void {\n        for (let index of this.indexes) {\n            this.setValue(index, null)\n        }\n    }\n\n    get nRows(): number {\n        return this._nRows\n    }\n\n    get nCols(): number {\n        return this._nCols\n    }\n\n    get constraints(): SudokuConstraint[] {\n        return this._constraints\n    }\n\n    public isValidIndex(index: SudokuIndex): boolean {\n        const {row, col} = index\n        return 0 <= row && row < this._nRows &&\n               0 <= col && col < this._nCols\n    }\n\n    public isValidValue(index: SudokuIndex, value: SudokuValue): boolean {\n        if (!SudokuCell.isValidValue(value)) {\n            return false\n        }\n        // value is potentially valid, next check constraints\n        for (let constraint of this._constraints) {\n            // If any constraint fails, then the value is not valid for this index\n            if (! constraint.allowsValue(this, index, value)) {\n                return false\n            }\n        }\n        // All constraints pass => value is valid for this index\n        return true\n    }\n\n    public blockedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = new Set<SudokuValue>()\n        for (let constraint of this._constraints) {\n            constraint.blockedValues(this, index).forEach(v => blockedValues.add(v))\n        }\n        return Array.from(blockedValues)\n    }\n\n    public allowedValues(index: SudokuIndex): SudokuValue[] {\n        const blockedValues = this.blockedValues(index)\n        return SudokuCell.ValidValues.filter(v => !blockedValues.includes(v))\n    }\n\n    public setValue(index: SudokuIndex, value: SudokuValue): void {\n        assert(this.isValidIndex(index))\n        const newValue = new SudokuCell(value)\n        assert(this.isValidValue(index, value))\n        const {row, col} = index\n        this._contents[row][col] = newValue\n        Sudoku._checksum += 1\n    }\n\n    public getValue(index: SudokuIndex): SudokuValue {\n        assert(this.isValidIndex(index))\n        const {row, col} = index\n        return this._contents[row][col].value\n    }\n\n    public get checksum() {\n        return Sudoku._checksum\n    }\n}\n","import { SudokuValue } from \"./SudokuCell\"\nimport { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { range } from \"../utils\"\n\nexport type SudokuArea = {\n    from: SudokuIndex\n    to: SudokuIndex\n}\n\nexport abstract class SudokuConstraint {\n    private readonly _area: SudokuArea\n\n    protected constructor(area: SudokuArea) {\n        this._area = area\n    }\n\n    get firstRow(): number {\n        return this._area.from.row\n    }\n\n    get lastRow(): number {\n        return this._area.to.row\n    }\n\n    get firstCol(): number {\n        return this._area.from.col\n    }\n\n    get lastCol(): number {\n        return this._area.to.col\n    }\n\n    appliesTo(index: SudokuIndex): boolean {\n        return this.firstRow <= index.row && index.row <= this.lastRow &&\n               this.firstCol <= index.col && index.col <= this.lastCol\n    }\n\n    constraintIndexes(sudoku: Sudoku): SudokuIndex[] {\n        let indexes = []\n        for (let row of range(this.firstRow, this.lastRow + 1)) {\n            for (let col of range(this.firstCol, this.lastCol + 1)) {\n                indexes.push(new SudokuIndex(row, col))\n            }\n        }\n        return indexes\n    }\n\n    blockedValues(sudoku: Sudoku, index: SudokuIndex): SudokuValue[] {\n        if (this.appliesTo(index)) {\n            const value = sudoku.getValue(index)    // don't block current value\n            return this.constraintIndexes(sudoku)\n                .map(index => sudoku.getValue(index))\n                .filter(v => !(v === null || v === value))\n        } else {\n            return []\n        }\n    }\n\n    allowsValue(sudoku: Sudoku, index: SudokuIndex, value: SudokuValue) {\n        if (value === null) {\n            // It is always possible to clear a value\n            return true\n        } else if (this.appliesTo(index)) {\n            // Check constraint\n            for (let constraintIndex of this.constraintIndexes(sudoku)) {\n                if (constraintIndex.row === index.row && constraintIndex.col === index.col) {\n                    // Overwrite of own value should be possible\n                    continue\n                }\n                if (sudoku.getValue(constraintIndex) === value) {\n                    // Value is already present in the constrained area\n                    return false\n                }\n            }\n        }\n        return true\n    }\n}\n\nexport class SudokuRowConstraint extends SudokuConstraint {\n    constructor(row: number, colFrom: number = 0, colTo: number = 8) {\n        super({from: new SudokuIndex(row, colFrom), to: new SudokuIndex(row, colTo)})\n    }\n}\n\nexport class SudokuColumnConstraint extends SudokuConstraint {\n    constructor(col: number, rowFrom: number = 0, rowTo: number = 8) {\n        super({from: new SudokuIndex(rowFrom, col), to: new SudokuIndex(rowTo, col)})\n    }\n}\n\nexport class SudokuAreaConstraint extends SudokuConstraint {\n    constructor(row: number, col: number, size: number = 3) {\n        super({from: new SudokuIndex(row, col), to: new SudokuIndex(row + size - 1, col + size - 1)})\n    }\n}\n","export type ImportDataItem = [number, number, number]\n\nexport class SudokuImport {\n    public readonly setup: Promise<void>\n    private _data: {[id: string]: ImportDataItem[]} = {}\n\n    constructor(dataURL: string) {\n        this.setup = this.loadJSON(window.location.href + dataURL)\n    }\n\n    private async loadJSON(dataURL: string) {\n        const response = await fetch(dataURL)\n        this._data = await response.json()\n    }\n\n    getData(id: string): ImportDataItem[] {\n        if (id in this._data) {\n            return this._data[id]\n        }\n        return []\n    }\n\n    get ids(): string[] {\n        return Object.keys(this._data)\n    }\n}","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { range } from \"../utils\"\nimport { SudokuAreaConstraint, SudokuColumnConstraint, SudokuConstraint, SudokuRowConstraint } from \"./SudokuConstraint\"\nimport { SudokuVariant } from \"./SudokuVariants\"\nimport { ImportDataItem, SudokuImport } from \"./SudokuImport\"\n\nexport class SudokuFactory {\n    private static _data: {[dataURL: string]: SudokuImport} = {}\n\n    private static getAreaConstraints(areas: number[]): SudokuConstraint[] {\n        const areaConstraints: SudokuConstraint[] = []\n        areas.forEach(row => {\n            areas.forEach(col => {\n                areaConstraints.push(new SudokuAreaConstraint(row, col))\n            })\n        })\n        return areaConstraints\n    }\n\n    private static getBasicConstraints(nRows: number, nCols: number): SudokuConstraint[] {\n        const rowConstraints = range(nRows).map(r => new SudokuRowConstraint(r))\n        const colConstraints = range(nCols).map(c => new SudokuColumnConstraint(c))\n        const areaConstraints = SudokuFactory.getAreaConstraints([0, 3, 6])\n        return [...rowConstraints, ...colConstraints, ...areaConstraints]\n    }\n\n    public static create(variant: SudokuVariant) {\n        return variant.create()\n    }\n\n    public static async dataIds(variant: SudokuVariant): Promise<string[]> {\n        const importer = await SudokuFactory.loadData(variant.dataURL)\n        return importer.ids\n    }\n\n    public static createBasicSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        return new Sudoku(nRows, nCols, constraints);\n    }\n\n    public static createNRCSudoku(): Sudoku {\n        const nRows = 9\n        const nCols = 9\n\n        const constraints = SudokuFactory.getBasicConstraints(nRows, nCols)\n        const subConstraints = SudokuFactory.getAreaConstraints([1, 5])\n        return new Sudoku(nRows, nCols, [...constraints, ...subConstraints]);\n    }\n\n    private static async fillSudoku(sudoku: Sudoku, dataURL: string, id: string) {\n        const importer = await SudokuFactory.loadData(dataURL)\n        const importDataItems = importer.getData(id)\n        SudokuFactory.fillData(sudoku, importDataItems)\n    }\n\n    public static fillData(sudoku: Sudoku, importDataItems: ImportDataItem[]) {\n        // Clear any existing values\n        for (let index of sudoku.indexes) {\n            sudoku.setValue(index, null)\n        }\n\n        // Fill with new data\n        for (let [row, col, value] of importDataItems) {\n            sudoku.setValue(new SudokuIndex(row, col), value);\n        }\n    }\n\n    private static async loadData(dataURL: string): Promise<SudokuImport> {\n        if (!SudokuFactory._data[dataURL]) {\n            const importer = new SudokuImport(dataURL)\n            await importer.setup\n            SudokuFactory._data[dataURL] = importer\n        }\n        return SudokuFactory._data[dataURL]\n    }\n\n    public static async fillNRCSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/nrc.json\", id)\n    }\n\n    public static async fillBasicSudoku(sudoku: Sudoku, id: string = \"default\") {\n        await SudokuFactory.fillSudoku(sudoku, \"/data/basic.json\", id)\n    }\n}","import { SudokuFactory } from \"./SudokuFactory\"\nimport { Sudoku } from \"./Sudoku\"\n\nexport interface SudokuVariant {\n    id: string\n    name: string\n    create: () => Sudoku\n    fill: (sudoku: Sudoku, id?: string) => Promise<void>\n    dataURL: string\n}\n\nexport const SudokuVariants = {\n    Basic: {\n        id: \"Basic\",\n        name: \"Standard Sudoku\",\n        create: SudokuFactory.createBasicSudoku,\n        fill: SudokuFactory.fillBasicSudoku,\n        dataURL: \"/data/basic.json\"\n    },\n    NRC: {\n        id: \"NRC\",\n        name: \"NRC Sudoku\",\n        create: SudokuFactory.createNRCSudoku,\n        fill: SudokuFactory.fillNRCSudoku,\n        dataURL: \"/data/nrc.json\"\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuHelper } from \"../SudokuHelper\"\nimport { SudokuAction } from \"./SudokuAction\"\n\nexport abstract class SudokuStrategy {\n    protected helper: SudokuHelper\n\n    constructor(helper: SudokuHelper) {\n        this.helper = helper\n    }\n\n    public abstract values(index: SudokuIndex): SudokuValue[]\n\n    public abstract process(index: SudokuIndex): SudokuAction[]\n\n    get sudoku() {\n        return this.helper.sudoku\n    }\n\n    get indexInfo() {\n        return this.helper.indexInfo\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { getAllSubsets } from \"../../utils\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuConstraint, SudokuIndex, SudokuValue[], SudokuIndex[]]\n\nexport class HiddenPair extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const values = this.getValues(index)\n        return Array.from(\n            values.reduce((result: Set<SudokuValue>,\n                           [constraint, index, subset, identicalIndexes]: ValuesResult) => {\n                subset.forEach(v => result.add(v))\n                return result\n            }, new Set<SudokuValue>())\n        )\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const allowedValues = this.indexInfo[index.id].allowedValues\n\n        // Pairs within a constraint with identical allowed values is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Search for subsets of a minimum length of 2 and less than the length of the allowed values\n        // Length 1 cannot result in a usable set\n        const subsets = getAllSubsets(allowedValues)\n            .filter((set: SudokuValue[]) => 2 <= set.length && set.length <= allowedValues.length)\n\n        // Find any applicable constraints\n        const constraints = this.sudoku.constraints\n            .filter(c => c.appliesTo(index))\n\n        let result: ValuesResult[] = []\n        for (let subset of subsets) {\n            // Check every subset\n            for (let constraint of constraints) {\n                // Find all indexes that contain this subset\n                const identicalIndexes = constraint.constraintIndexes(this.sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (!this.indexInfo[i.id].allowedValues.includes(n)) return false\n                        }\n                        return true\n                    })\n                if (identicalIndexes.length !== subset.length) {\n                    continue\n                }\n\n                // Find all indexes that don't contain any of the subset\n                const inIndexes = constraint.constraintIndexes(this.sudoku)\n                    .filter(i => {\n                        for (let n of subset) {\n                            if (this.indexInfo[i.id].allowedValues.includes(n)) return true\n                        }\n                        return false\n                    })\n                if (identicalIndexes.length !== inIndexes.length) {\n                    continue\n                }\n\n                result.push([constraint, index, subset, identicalIndexes])\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((result: SudokuAction[],\n                              [constraint, index, subset, identicalIndexes]: ValuesResult) => {\n                result.concat(this.action(constraint, index, subset, identicalIndexes))\n                return result\n            }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   index: SudokuIndex,\n                   values: SudokuValue[],\n                   identicalIndexes: SudokuIndex[]): SudokuAction[] {\n        const result: SudokuAction[] = []\n        identicalIndexes.forEach(i => {\n            const allowedValues = this.indexInfo[i.id].allowedValues\n            if (allowedValues.length !== values.length) {\n                result.push({\n                    motivation: \"Hidden pair\",\n                    constraints: [constraint],\n                    index: i,\n                    allowedValues: values\n\n                })\n            }\n        })\n        return result\n    }\n\n\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuValue, SudokuConstraint[]]\n\nexport class MandatoryValue extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const mandatoryValue = this.getValues(index)[0]\n        return mandatoryValue ? [mandatoryValue] : []\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult {\n        const info = this.indexInfo[index.id]\n        const applicableConstraints = this.sudoku.constraints.filter(c => c.appliesTo(index))\n\n        let mandatoryValue: SudokuValue = null\n        let constraints: SudokuConstraint[] = []\n\n        if (info.allowedValues.length === 1) {\n            return [info.allowedValues[0], []]\n        }\n        for (let value of info.allowedValues) {\n            // Try finding a value with only one possible index within a constraint\n            for (let constraint of applicableConstraints) {\n                let nPossibilities = 0\n                for (let constraintIndex of constraint.constraintIndexes(this.sudoku)) {\n                    if (this.indexInfo[constraintIndex.id].allowedValues.includes(value)) {\n                        nPossibilities += 1\n                        if (nPossibilities > 1) {\n                            // Stop searching this constraint as it allows for multiple indexes for the given value\n                            break;\n                        }\n                    }\n                }\n                if (nPossibilities === 1) {\n                    mandatoryValue = value\n                    constraints.push(constraint)\n                }\n            }\n        }\n        return [mandatoryValue, constraints]\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const [mandatoryValue, constraints] = this.getValues(index)\n        return mandatoryValue === null ? [] : [this.action(constraints, index, mandatoryValue)]\n    }\n\n    private action(constraints: SudokuConstraint[], index: SudokuIndex, value: SudokuValue) {\n        return {\n            motivation: `Value ${value} is the only possible value in this constraint`,\n            index,\n            constraints,\n            allowedValues: [value]\n        }\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport {\n    SudokuAreaConstraint,\n    SudokuColumnConstraint,\n    SudokuConstraint,\n    SudokuRowConstraint\n} from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuValue, SudokuConstraint, number | null, number | null]\n\nexport class SingleRowColumn extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        return this.getValues(index).map(([value, constraint, row, column]: ValuesResult) => value)\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const info = this.indexInfo[index.id]\n        const applicableConstraints = this.sudoku.constraints\n            .filter(c => c.appliesTo(index))\n            .filter(constraint => constraint instanceof SudokuAreaConstraint)\n\n        let result: ValuesResult[] = []\n        for (let value of info.allowedValues) {\n            // Try finding a value with all possible values on one row or one column\n            for (let constraint of applicableConstraints) {\n                let rows = new Set<number>()\n                let cols = new Set<number>()\n                for (let constraintIndex of constraint.constraintIndexes(this.sudoku)) {\n                    if (this.indexInfo[constraintIndex.id].allowedValues.includes(value)) {\n                        rows.add(constraintIndex.row)\n                        cols.add(constraintIndex.col)\n                    }\n                }\n                if (rows.size === 1 || cols.size === 1) {\n                    result.push([value, constraint, rows.size === 1 ? index.row : null, cols.size === 1 ? index.col : null])\n                }\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((actions: SudokuAction[],\n                              [value, constraint, row, column]: ValuesResult) => {\n            return actions.concat(this.action(constraint,\n                index,\n                value,\n                row,\n                column))\n        }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   index: SudokuIndex,\n                   value: SudokuValue,\n                   row: number | null,\n                   col: number | null): SudokuAction[] {\n        let rowColumnConstraints: SudokuConstraint[] = []\n        if (row !== null) {\n            rowColumnConstraints = this.sudoku.constraints\n                .filter(c => c.appliesTo(index) && c instanceof SudokuRowConstraint && c.firstRow === row)\n        } else if (col !== null) {\n            rowColumnConstraints = this.sudoku.constraints\n                .filter(c => c.appliesTo(index) && c instanceof SudokuColumnConstraint && c.firstCol === col)\n        }\n\n        const result: SudokuAction[] = []\n        for (let rowColumnConstraint of rowColumnConstraints) {\n            for (let rowColumnIndex of rowColumnConstraint.constraintIndexes(this.sudoku).filter(i => !constraint.appliesTo(i))) {\n                const allowedValues = this.indexInfo[rowColumnIndex.id].allowedValues\n                if (allowedValues.includes(value)) {\n                    result.push({\n                        motivation: `${value} is a single row/column value`,\n                        constraints: [constraint, rowColumnConstraint],\n                        allowedValues: allowedValues.filter(v => v !== value),\n                        index: rowColumnIndex\n                    })\n                }\n            }\n        }\n        return result\n    }\n}\n","import { SudokuIndex } from \"../Sudoku\"\nimport { SudokuConstraint } from \"../SudokuConstraint\"\nimport { SudokuValue } from \"../SudokuCell\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\nimport { SudokuAction } from \"./SudokuAction\"\n\ntype ValuesResult = [SudokuConstraint, SudokuIndex[], SudokuValue[]]\n\nexport class NakedPair extends SudokuStrategy {\n    public values(index: SudokuIndex): SudokuValue[] {\n        const values = this.getValues(index)\n        return Array.from(\n            values.reduce((result: Set<SudokuValue>,\n                           [constraint, indexes, allowedValues]: ValuesResult) => {\n                allowedValues.forEach(v => result.add(v))\n                return result\n            }, new Set<SudokuValue>())\n        )\n    }\n\n    private getValues(index: SudokuIndex): ValuesResult[] {\n        const info = this.indexInfo[index.id]\n        const allowedValues = info.allowedValues\n\n        // Pairs within a constraint with identical allowed value is not possible\n        if (allowedValues.length === 1) {\n            return []\n        }\n\n        // Find any applicable constraints\n        const applicableConstraints = this.sudoku.constraints.filter(c => c.appliesTo(index))\n\n        let result: ValuesResult[] = []\n        for (let constraint of applicableConstraints) {\n            const identicalIndexes = constraint.constraintIndexes(this.sudoku)\n                .filter(i => allowedValues.join('') === this.indexInfo[i.id].allowedValues.join(''))\n            // A pair is a set of indexes with identical values, eg [[x, y] [x, y]] or [[x, y, z] [x, y, z]]\n            if (identicalIndexes.length === allowedValues.length) {\n                // n pairs with identical n values\n                result.push([constraint, identicalIndexes, allowedValues])\n            }\n        }\n        return result\n    }\n\n    public process(index: SudokuIndex): SudokuAction[] {\n        const values = this.getValues(index)\n        return values.reduce((result: SudokuAction[], [constraint, indexes, allowedValues]: ValuesResult) => {\n            return result.concat(this.action(constraint, indexes, allowedValues))\n        }, [] as SudokuAction[])\n    }\n\n    private action(constraint: SudokuConstraint,\n                   identicalIndexes: SudokuIndex[],\n                   values: SudokuValue[]): SudokuAction[] {\n        const identicalIds = identicalIndexes.map(i => i.id)\n        const otherIndexes = constraint.constraintIndexes(this.sudoku)\n            .filter(i => !identicalIds.includes(i.id))\n        const actions: SudokuAction[] = []\n        otherIndexes.forEach(i => {\n            const info = this.indexInfo[i.id]\n            const eliminateValues = info.allowedValues.filter(v => values.includes(v))\n            if (eliminateValues.length > 0) {\n                const allowedValues = info.allowedValues.filter(v => !values.includes(v))\n                actions.push({\n                    motivation: `Eliminate naked pair values ${eliminateValues.join(\", \")}`,\n                    constraints: [constraint],\n                    index: i,\n                    allowedValues: allowedValues\n                })\n            }\n        })\n        return actions\n    }\n}\n","import { HiddenPair } from \"./HiddenPair\"\nimport { MandatoryValue } from \"./MandatoryValue\"\nimport { SingleRowColumn } from \"./SingleRowColumn\"\nimport { NakedPair } from \"./NakedPair\"\nimport { SudokuHelper } from \"../SudokuHelper\"\nimport { SudokuStrategy } from \"./SudokuStrategy\"\n\nexport interface SudokuStrategyConfig {\n    create: (helper: SudokuHelper) => SudokuStrategy,\n    option: {\n        text: string\n    },\n    style: {\n        color: string\n    }\n}\n\ninterface ISudokuStrategies {\n    MandatoryValue: SudokuStrategyConfig\n    SingleRowColumn: SudokuStrategyConfig\n    NakedPair: SudokuStrategyConfig\n    HiddenPair: SudokuStrategyConfig\n}\n\nexport type SudokuStrategyKeys = keyof ISudokuStrategies\n\nexport function strategyMapping<T>(mapping: (strategy: SudokuStrategyKeys, config: SudokuStrategyConfig) => T) {\n    return Object.entries(SudokuStrategies).reduce((result, [key, config]) => {\n        const strategy = key as SudokuStrategyKeys\n        result[strategy] = mapping(strategy as SudokuStrategyKeys, config)\n        return result\n    }, {} as Record<SudokuStrategyKeys, T>)\n}\n\nexport const SudokuStrategies: ISudokuStrategies = {\n    MandatoryValue: {\n        create: (helper: SudokuHelper) => new MandatoryValue(helper),\n        option: {\n            text: \"Show mandatory values\"\n        },\n        style: {\n            color: \"purple\"\n        }\n    },\n    NakedPair: {\n        create: (helper: SudokuHelper) => new NakedPair(helper),\n        option: {\n            text: \"Show pairs\"\n        },\n        style: {\n            color: \"red\"\n        }\n    },\n    HiddenPair: {\n        create: (helper: SudokuHelper) => new HiddenPair(helper),\n        option: {\n            text: \"Show hidden pairs\"\n        },\n        style: {\n            color: \"blue\"\n        }\n    },\n    SingleRowColumn: {\n        create: (helper: SudokuHelper) => new SingleRowColumn(helper),\n        option: {\n            text: \"Show single row/column\"\n        },\n        style: {\n            color: \"green\"\n        }\n    }\n}\n","import { SudokuVariants } from \"./types/SudokuVariants\"\nimport { strategyMapping, SudokuStrategyKeys } from \"./types/SudokuStrategies\"\n\nexport type { SudokuStrategyKeys } from \"./types/SudokuStrategies\"\nexport { SudokuStrategies, strategyMapping } from \"./types/SudokuStrategies\"\n\nexport type SudokuOptionKeys = \"PossibleValues\" |\n    \"Hint\" |\n    SudokuStrategyKeys\n\nexport type SudokuOptions = Record<SudokuOptionKeys, boolean>\n\nconst DefaultOptions: SudokuOptions = {\n    PossibleValues: false,\n    Hint: false,\n    ...strategyMapping(() => false)\n}\n\nexport const Default = {\n    sudokuVariant: SudokuVariants.Basic,\n    options: DefaultOptions\n}\n","import React, { ChangeEvent, useState } from 'react'\n\nimport { Input } from \"@material-ui/core\"\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        textField: {\n            '& > *': {\n                textAlign: \"center\",\n            },\n        }\n    }),\n);\n\nexport interface SudokuCellEditorProps {\n    sudoku: Sudoku,\n    sudokuOptions: SudokuOptions,\n    index: SudokuIndex,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nexport default function SudokuCellEditor(props: SudokuCellEditorProps) {\n    const classes = useStyles();\n\n    const { sudoku, sudokuOptions, index } = props\n\n    const [value, setValue] = useState(sudoku.getValue(index) || \"\")\n\n    const onChange = (event: ChangeEvent<HTMLInputElement>): void => {\n        const newValue: SudokuValue = Number(event.target.value)\n        const value = props.onChange(index, isNaN(newValue) ? null : newValue)\n        setValue(value || \"\")\n    }\n\n    if (sudokuOptions.Hint && !value) {\n        return null\n    }\n\n    return (\n        <form noValidate autoComplete=\"off\">\n            <Input className={classes.textField} disableUnderline={true}\n                   value={value}\n                   onChange={onChange}/>\n        </form>\n    );\n}\n","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { IconButton } from \"@material-ui/core\"\nimport { SudokuOptions } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            position: \"absolute\",\n            top: 7,\n            left: 8,\n            textAlign: \"center\",\n            marginLeft: \"2px\",\n        },\n    }),\n);\n\nexport interface SudokuHintProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuHint(props: SudokuHintProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    const allowedValues = sudokuHelper.allowedValues(index)\n\n    if (value !== null || !options.Hint || allowedValues.length !== 1) {\n        // Nothing for existing values\n        return null\n    }\n\n    const onProposalClick = (proposal:number) => {\n        props.onChange(index, proposal)\n    }\n\n    return (\n        <IconButton\n            className={classes.root}\n            size={\"small\"}\n            color={\"secondary\"}\n            onClick={() => onProposalClick(allowedValues[0]!)}>\n            ?\n        </IconButton>\n    )\n}\n\nexport default SudokuHint","import React from 'react';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport { SudokuOptionKeys, SudokuOptions, strategyMapping } from \"../config\"\n\nexport interface SudokuOptionsEditorProps {\n    options: SudokuOptions,\n    onOption: (name: string, value: boolean) => void\n}\n\nexport default function SudokuOptionsEditor(props: SudokuOptionsEditorProps) {\n    const [state, setState] = React.useState(props.options);\n\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { name, checked } = event.target\n        setState({ ...state, [name]: checked });\n        props.onOption(name, checked)\n    };\n\n    const switches: Record<SudokuOptionKeys, string> = {\n        PossibleValues: \"Show possible values\",\n        Hint: \"Show hint\",\n        ...strategyMapping((strategy, config) => config.option.text)\n    }\n\n    return (\n        <FormControl component=\"fieldset\">\n            <FormGroup>\n                {Object.entries(switches).map(([name, label]) => {\n                    const key = name as keyof SudokuOptions\n                    return (\n                        <FormControlLabel key={key}\n                            control={\n                                <Switch checked={state[key]}\n                                        onChange={handleChange}\n                                        name={name}/>\n                            }\n                            label={label}\n                        />\n                    )\n                })}\n            </FormGroup>\n        </FormControl>\n    );\n}\n","import React from 'react'\nimport { Button } from \"@material-ui/core\"\nimport BuildIcon from '@material-ui/icons/Build'\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuIndex } from \"../types/Sudoku\"\n\nexport interface SudokuSolverProps {\n    sudokuHelper: SudokuHelper,\n    onChange: (index: SudokuIndex, value: SudokuValue) => SudokuValue\n}\n\nfunction SudokuSolver(props: SudokuSolverProps) {\n    const {sudokuHelper, onChange} = props\n\n    const solve = () => {\n        const hint = sudokuHelper.getHint()\n        if (hint) {\n            const [index, value] = hint\n            onChange(index, value)\n            setTimeout(() => solve(), 0)\n        }\n    }\n\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<BuildIcon />}\n            onClick={solve}\n        >\n            Solve\n        </Button>\n    )\n}\n\nexport default SudokuSolver","import React from 'react'\n\nimport { Button } from \"@material-ui/core\"\nimport DeleteIcon from \"@material-ui/icons/Delete\"\n\nexport interface SudokuEraserProps {\n    onErase: () => void\n}\n\nfunction SudokuEraser(props: SudokuEraserProps) {\n    return (\n        <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<DeleteIcon />}\n            onClick={props.onErase}\n        >\n            Clear\n        </Button>\n    )\n}\n\nexport default SudokuEraser","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuCell, SudokuValue } from \"../types/SudokuCell\"\nimport { SudokuOptions, SudokuStrategyKeys, strategyMapping } from \"../config\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        possibleValues: {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            textAlign: \"left\",\n            marginLeft: \"2px\",\n            fontSize: \"10px\",\n            fontFamily: \"monospace\"\n        },\n        possibleValue: {},\n        ...strategyMapping((strategy, config) => config.style)\n    }),\n);\n\nexport interface SudokuPossibilitiesProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n}\n\nfunction SudokuPossibilities(props: SudokuPossibilitiesProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    // Check is any option is selected\n    const anyOptionSelected = Object.values(options)\n        .reduce((result: boolean, option: boolean) => result || option, false)\n\n    if (value !== null || !anyOptionSelected) {\n        // Nothing for existing values or when filtered out by options\n        return null\n    }\n\n    const strategies = sudokuHelper.strategies\n    const strategyValues = strategyMapping((strategy, config) =>\n        strategies[strategy].values(index))\n\n    let values: SudokuValue[] = []\n    if (options.PossibleValues) {\n        values = sudokuHelper.allowedValues(index)\n    } else {\n        values = Array.from(\n            Object.entries(strategyValues).reduce((result, [key, values]) => {\n                if (options[key as SudokuStrategyKeys]) {\n                    values.forEach(v => result.add(v))\n                }\n                return result\n            }, new Set<SudokuValue>()))\n    }\n\n    if (values.length === 0) {\n        // Nothing to show\n        return null\n    }\n\n    const displayValues = SudokuCell.ValidValues.map(v => {\n        return values.includes(v) ? v : \" \"\n    })\n    const lines = [0, 3, 6].map(n => displayValues.slice(n, n + 3))\n\n    return (\n        <div className={classes.possibleValues}>\n            {lines.map((line, i) => <div key={i}>\n                {line.map((c, i) => {\n                    if (c === \" \") {\n                        return <span key={i}>&nbsp;</span>\n                    } else {\n                        let classNames = [classes.possibleValue]\n                        Object.entries(strategyValues).forEach(([key, value]) => {\n                            const strategy = key as SudokuStrategyKeys\n                            if (options[strategy] && strategyValues[strategy].includes(c)) {\n                                classNames.push(classes[strategy])\n                            }\n                        })\n                        return <span key={i} className={classNames.join(' ')}>{c}</span>\n                    }\n                })}\n            </div>)}\n        </div>\n    )\n}\n\nexport default SudokuPossibilities","import React from 'react'\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { IconButton } from \"@material-ui/core\"\nimport { SudokuOptions } from \"../config\"\nimport { SudokuAction } from \"../types/SudokuStrategies/SudokuAction\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            position: \"absolute\",\n            top: 7,\n            left: 8,\n            textAlign: \"center\",\n            marginLeft: \"2px\",\n        },\n    }),\n);\n\nexport interface SudokuActionProposalProps {\n    sudoku: Sudoku,\n    sudokuHelper: SudokuHelper,\n    options: SudokuOptions,\n    index: SudokuIndex\n    onAction: (actions: SudokuAction[]) => void\n}\n\nfunction SudokuActionProposal(props: SudokuActionProposalProps) {\n    const classes = useStyles();\n    const { sudoku, sudokuHelper, options, index } = props\n    const value = sudoku.getValue(index)\n\n    const allowedValues = sudokuHelper.allowedValues(index)\n    const actionProposals = sudokuHelper.actions[index.id] || []\n\n    if (value !== null || !options.Hint || allowedValues.length === 1 || actionProposals.length === 0) {\n        // Nothing for existing values\n        return null\n    }\n\n    const title = Array.from(new Set(actionProposals.map(proposal => proposal.motivation))).join(', ')\n\n    const onProposalClick = (actions: SudokuAction[]) => {\n        props.onAction(actions)\n    }\n\n    return (\n        <IconButton\n            className={classes.root}\n            size={\"small\"}\n            color={\"secondary\"}\n            onClick={() => onProposalClick(actionProposals)}\n            title={title}>\n            !\n        </IconButton>\n    )\n}\n\nexport default SudokuActionProposal","import React, { useState } from 'react'\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Sudoku, SudokuIndex } from \"../types/Sudoku\"\nimport SudokuCellEditor from \"./SudokuCellEditor\"\nimport SudokuHint from \"./SudokuHint\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\nimport { SudokuValue } from \"../types/SudokuCell\"\nimport SudokuOptionsEditor from \"./SudokuOptionsEditor\"\nimport SudokuSolver from \"./SudokuSolver\"\nimport SudokuEraser from \"./SudokuEraser\"\nimport { Default } from \"../config\"\nimport SudokuPossibilities from \"./SudokuPossibilities\"\nimport { getStyle } from \"../types/SudokuStyler\"\nimport { Box, Grid } from \"@material-ui/core\"\nimport SudokuActionProposal from \"./SudokuActionProposal\"\nimport { SudokuAction } from \"../types/SudokuStrategies/SudokuAction\"\n\nexport interface SudokuEditorProps {\n    sudoku: Sudoku,\n    helper: SudokuHelper\n}\n\nconst CELL_WIDTH = 35\nconst CELL_HEIGHT = 35\n\nexport function SudokuEditor(props:SudokuEditorProps) {\n    const [change, setChange] = useState(\"\")\n    const [options, setOptions] = useState(Default.options)\n\n    const { sudoku, helper } = props\n\n    const useStyles = makeStyles({\n        table: {\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            border: \"1px solid black\",\n            borderSpacing: 0,\n        },\n        tableCell: {\n            position: \"relative\",\n            backgroundColor: \"inherit\",\n            border: \"1px solid black\",\n            padding: 0,\n            margin: 0,\n            textAlign: \"center\",\n            verticalAlign: \"center\",\n            width: CELL_WIDTH,\n            height: CELL_HEIGHT,\n        },\n    });\n    const classes = useStyles();\n\n    const getKey = (index: SudokuIndex, value: SudokuValue) => {\n        return `${index.row}.${index.col}.${value}`\n    }\n\n    const onChange = (index: SudokuIndex, value: SudokuValue) => {\n        if (sudoku.isValidValue(index, value)) {\n            sudoku.setValue(index, value)\n        } else {\n            sudoku.setValue(index, null)\n        }\n        value = sudoku.getValue(index)\n        setChange(getKey(index, value))\n        return value\n    }\n\n    const onOption = (name: string, value: boolean) => {\n        setOptions({\n            ...options,\n            [name]: value\n        })\n    }\n\n    const onAction = (actions: SudokuAction[]) => {\n        helper.applyActions(actions)\n        setChange(actions.map(action => action.index.id).join(','))\n    }\n\n    const onErase = () => {\n        sudoku.clear()\n        setChange(\"Clear\")\n    }\n\n    return (\n        <div>\n        <Grid container\n              direction={\"column\"}\n              justify={\"space-around\"}\n              alignItems={\"center\"}>\n            <table className={classes.table}>\n                <tbody>\n                {sudoku.rowIndexes.map(row => {\n                    return (\n                        <tr key={row}>\n                            {sudoku.colIndexes.map(col => {\n                                const index = new SudokuIndex(row, col)\n                                const key = getKey(index, sudoku.getValue(index))\n                                const style = getStyle(sudoku, index)\n                                if (key === change) {\n                                    // Mark last changed index\n                                    style.backgroundColor = \"LightBlue\"\n                                }\n                                return (\n                                    <td key={key} className={classes.tableCell} style={style}>\n                                        <SudokuPossibilities sudoku={sudoku}\n                                                             sudokuHelper={helper}\n                                                             options={options}\n                                                             index={index}/>\n                                        <SudokuHint sudoku={sudoku}\n                                                    sudokuHelper={helper}\n                                                    options={options}\n                                                    index={index}\n                                                    onChange={onChange}/>\n                                        <SudokuActionProposal sudoku={sudoku}\n                                                              sudokuHelper={helper}\n                                                              options={options}\n                                                              index={index}\n                                                              onAction={onAction}/>\n                                        <SudokuCellEditor sudoku={sudoku}\n                                                          sudokuOptions={options}\n                                                          index={index}\n                                                          onChange={onChange}/>\n                                    </td>\n                                )\n                            })}\n                        </tr>\n                    )\n                })}\n                </tbody>\n            </table>\n\n            </Grid>\n\n            <Grid\n                container\n                direction=\"row\"\n                justify=\"space-between\"\n                alignItems=\"flex-start\"\n            >\n\n            <SudokuOptionsEditor options={options} onOption={onOption}/>\n\n            <div style={{textAlign: \"right\"}}>\n                <Box mt={1}>\n                    <SudokuSolver sudokuHelper={helper} onChange={onChange}/>\n                </Box>\n\n                <Box mt={1} mb={2}>\n                    <SudokuEraser onErase={onErase}/>\n                </Box>\n            </div>\n\n            </Grid>\n\n            {/*<Box m={2}>*/}\n            {/*    {values.map((value, i) => (*/}\n            {/*        <div key={i}>*/}\n            {/*            [{value.join(\", \")}],*/}\n            {/*        </div>*/}\n            {/*    ))}*/}\n            {/*</Box>*/}\n\n        </div>\n    );\n}\n\nexport default SudokuEditor\n","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuAreaConstraint } from \"./SudokuConstraint\"\n\nexport function getStyle(sudoku: Sudoku, index: SudokuIndex) {\n    const defaultBorder = \"1px solid black\"\n    const boldBorder = \"2px solid black\"\n    const style = {\n        borderTop: defaultBorder,\n        borderRight: defaultBorder,\n        borderBottom: defaultBorder,\n        borderLeft: defaultBorder,\n        backgroundColor: \"inherit\"\n    }\n    for (let constraint of sudoku.constraints) {\n        if (constraint instanceof SudokuAreaConstraint) {\n            if ([1, 5].includes(constraint.firstRow) || [1,5].includes(constraint.firstCol)) {\n                if (constraint.appliesTo(index)) {\n                    style.backgroundColor = \"lightGrey\"\n                }\n                continue\n            }\n            if (index.row === constraint.firstRow) {\n                style.borderTop = boldBorder\n            } else if (index.row === constraint.lastRow) {\n                style.borderBottom = boldBorder\n            }\n            if (index.col === constraint.firstCol) {\n                style.borderLeft = boldBorder\n            } else if (index.col === constraint.lastCol) {\n                style.borderRight = boldBorder\n            }\n        }\n    }\n    return style\n}","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\nimport { SudokuVariant, SudokuVariants } from \"../types/SudokuVariants\"\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuVariantSelectorProps {\n    variant: SudokuVariant,\n    onVariant: (variant: SudokuVariant) => void\n}\n\nexport default function SudokuVariantSelector(props: SudokuVariantSelectorProps) {\n    const classes = useStyles();\n    const [variant, setVariant] = useState(props.variant)\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        const variant = Object.values(SudokuVariants).filter(v => v.id === id)\n        if (variant.length) {\n            setVariant(variant[0])\n            props.onVariant(variant[0])\n        }\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Variant</InputLabel>\n                <Select\n                    native\n                    value={variant.id}\n                    onChange={onChange}\n                >\n                    {Object.values(SudokuVariants).map((option: SudokuVariant) => (\n                        <option key={option.id} value={option.id}>{option.name}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import React, { useState } from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        formControl: {\n            margin: theme.spacing(1),\n            minWidth: 140,\n        },\n        selectEmpty: {\n            marginTop: theme.spacing(2),\n        },\n    }),\n);\n\nexport interface SudokuIdSelectorProps {\n    id: string,\n    ids: string[],\n    onId: (id: string) => void\n}\n\nexport default function SudokuIdSelector(props: SudokuIdSelectorProps) {\n    const classes = useStyles();\n    const [id, setId] = useState(props.id)\n    const {ids, onId} = props\n\n    const onChange = (event: React.ChangeEvent<{ name?: string; value: unknown }>) => {\n        const id = event.target.value as string\n        setId(id)\n        onId(id)\n    }\n\n    return (\n        <div>\n            <FormControl className={classes.formControl}>\n                <InputLabel>Sudoku Data</InputLabel>\n                <Select\n                    native\n                    value={id}\n                    onChange={onChange}\n                >\n                    {ids.map(id => (\n                        <option key={id} value={id}>{id}</option>\n                    ))}\n                </Select>\n            </FormControl>\n        </div>\n    );\n}\n","import { Sudoku, SudokuIndex } from \"./Sudoku\"\nimport { SudokuValue } from \"./SudokuCell\"\nimport { strategyMapping } from \"../config\"\nimport { SudokuAction } from \"./SudokuStrategies/SudokuAction\"\nimport { SudokuStrategy } from \"./SudokuStrategies/SudokuStrategy\"\nimport assert from \"assert\"\n\nexport class SudokuIndexInfo {\n    private _allowedValues: SudokuValue[]\n\n    constructor(allowedValues: SudokuValue[]) {\n        this._allowedValues = allowedValues\n    }\n\n    get allowedValues() {\n        return this._allowedValues\n    }\n\n    set allowedValues(values) {\n        this._allowedValues = values\n    }\n}\n\ntype Hint = [SudokuIndex, SudokuValue]\n\ntype IndexActions = {[key: string]: SudokuAction[]}\n\nexport class SudokuHelper {\n    readonly sudoku: Sudoku\n    readonly indexInfo: {\n        [key: string]: SudokuIndexInfo\n    } = {}\n    private sudokuChecksum: number\n    private _actions: IndexActions | null = null\n\n    constructor(sudoku: Sudoku) {\n        this.sudoku = sudoku\n        this.sudokuChecksum = -1\n        this.prepare()\n    }\n\n    private prepare() {\n        if (this.sudokuChecksum !== this.sudoku.checksum) {\n            this.sudoku.indexes.forEach(index => {\n                const value = this.sudoku.getValue(index)\n                const allowedValues = value === null ? this.sudoku.allowedValues(index) : []\n                const indexInfo = new SudokuIndexInfo(allowedValues)\n                this.indexInfo[index.id] = indexInfo\n            })\n            this.sudokuChecksum = this.sudoku.checksum\n        }\n    }\n\n    get strategies() {\n        return strategyMapping((strategy, config) =>\n            config.create(this))\n    }\n\n    get actions(): IndexActions {\n        if (this._actions === null || this.sudokuChecksum !== this.sudoku.checksum) {\n            this.refreshActions()\n        }\n        assert(this._actions !== null)\n        return this._actions\n    }\n\n    private refreshActions() {\n        this._actions = this.getActions()\n    }\n\n    private getActions(strategy: SudokuStrategy | null = null): IndexActions {\n        this.prepare()\n\n        const strategies = strategy === null ? this.strategies : [strategy]\n        const actions: IndexActions = {}\n        Object.values(strategies).forEach(strategy => {\n            this.sudoku.indexes.forEach(index => {\n                strategy.process(index).forEach(action => {\n                    actions[action.index.id] = actions[action.index.id] || []\n                    actions[action.index.id].push(action)\n                })\n            })\n        })\n        return actions\n    }\n\n    public applyActions(actions: SudokuAction[]) {\n        actions.forEach(action => {\n            const info = this.indexInfo[action.index.id]\n            info.allowedValues = action.allowedValues\n            this._actions = null    // actions needs refresh\n        })\n    }\n\n    public getHint(): Hint | undefined {\n        this.prepare()\n\n        const strategies = Object.values(this.strategies)\n\n        let actionsApplied = true\n        while (actionsApplied) {\n            actionsApplied = false\n            for (let strategy of strategies) {\n                for (let index of this.sudoku.indexes) {\n                    const info = this.indexInfo[index.id]\n                    if (info.allowedValues.length === 1) {\n                        return [index, info.allowedValues[0]]\n                    }\n                }\n\n                for (let actions of Object.values(this.getActions(strategy))) {\n                    this.applyActions(actions)\n                    actionsApplied = true\n                }\n            }\n        }\n    }\n\n    public applyHint([index, value]: Hint) {\n        this.sudoku.setValue(index, value)\n    }\n\n    public allowedValues(index: SudokuIndex) {\n        return this.indexInfo[index.id].allowedValues\n    }\n}\n","import React, { useState } from 'react'\n\nimport { Default } from \"../config\"\n\nimport { SudokuVariant } from \"../types/SudokuVariants\"\nimport { SudokuFactory } from \"../types/SudokuFactory\"\n\nimport SudokuEditor from \"./SudokuEditor\"\nimport SudokuVariantSelector from \"./SudokuVariantSelector\"\nimport { Grid, Paper } from \"@material-ui/core\"\nimport { Sudoku } from \"../types/Sudoku\"\nimport SudokuIdSelector from \"./SudokuIdSelector\"\nimport { SudokuHelper } from \"../types/SudokuHelper\"\n\nconst initialState = {\n    variant: Default.sudokuVariant,\n    ids: [] as string[],\n    id: \"\",\n    sudoku: null as Sudoku | null,\n    helper: null as SudokuHelper | null\n}\n\nexport default function SudokuApp() {\n    const [state, setState] = useState(initialState)\n    const {variant, ids, id, sudoku, helper} = state\n\n    async function loadVariant(variant: SudokuVariant) {\n        const sudoku = SudokuFactory.create(variant)\n        const ids = await SudokuFactory.dataIds(variant)\n        const id = ids[0]\n        await variant.fill(sudoku, id)\n        const helper = new SudokuHelper(sudoku)\n\n        setState({\n            ...state,\n            variant,\n            ids,\n            id,\n            sudoku,\n            helper\n        })\n    }\n\n    if (!sudoku) {\n        loadVariant(variant)\n        return (\n            <p>Loading...</p>\n        )\n    }\n\n    async function loadId(sudoku: Sudoku, id: string) {\n        await variant.fill(sudoku, id)\n    }\n\n    const onVariant = async (variant: SudokuVariant) => {\n        await loadVariant(variant)\n    }\n\n    const onId = async (id: string) => {\n        await loadId(sudoku, id)\n        setState({...state, id})\n    }\n\n    return (\n        <Paper elevation={3} style={{width: 375}}>\n            <Grid container\n                  direction={\"column\"}\n                  justify={\"space-around\"}\n                  alignItems={\"center\"}>\n                <Grid container\n                      direction={\"row\"}\n                      justify={\"space-around\"}\n                      alignItems={\"center\"}>\n                    <SudokuVariantSelector variant={variant} onVariant={onVariant}/>\n                    <SudokuIdSelector ids={ids} id={id} onId={onId}/>\n                </Grid>\n                <SudokuEditor sudoku={sudoku} helper={helper!}/>\n            </Grid>\n        </Paper>\n    )\n}","import React from 'react';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            flexGrow: 1,\n        },\n        menuButton: {\n            marginRight: theme.spacing(2),\n        },\n        title: {\n            flexGrow: 1,\n        },\n    }),\n);\n\nexport default function SudokuAppBar() {\n    const classes = useStyles();\n\n    return (\n        <div className={classes.root}>\n            <AppBar position=\"static\">\n                <Toolbar>\n                    <IconButton edge=\"start\" className={classes.menuButton} color=\"inherit\" aria-label=\"menu\">\n                        <MenuIcon />\n                    </IconButton>\n                    <Typography variant=\"h6\" className={classes.title}>\n                        Sudoku Solver\n                    </Typography>\n                </Toolbar>\n            </AppBar>\n        </div>\n    );\n}\n","import React from 'react';\r\n\r\nimport { Box, Grid } from \"@material-ui/core\"\r\n\r\nimport SudokuApp from \"./components/SudokuApp\"\r\nimport SudokuAppBar from \"./components/SudokuAppBar\"\r\n\r\nfunction App() {\r\n    return (\r\n        <div>\r\n            <Box mb={2}>\r\n                <SudokuAppBar/>\r\n            </Box>\r\n            <Grid container\r\n                  direction={\"column\"}\r\n                  alignItems={\"center\"}\r\n                  justify={\"center\"}>\r\n                <SudokuApp/>\r\n            </Grid>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n};\n\nexport const SudokuSlice = createSlice({\n    name: 'sudoku',\n    initialState,\n    reducers: {\n    },\n});\n\nexport default SudokuSlice.reducer","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\r\nimport sudokuReducer from './SudokuSlice';\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    counter: sudokuReducer,\r\n  },\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { store } from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}